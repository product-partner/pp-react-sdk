/* tslint:disable */
/* eslint-disable */
/**
 * Product Partner API
 * Product Partner APIs can create, list, and modify goals, prds, status updates, and other product management artifacts.
 *
 * The version of the OpenAPI document: v1
 * Contact: info@productpartner.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'street_address': string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'postal_code': string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'country': string;
}
/**
 * Response can be either chat content, a stream URL, a UI command, or a status message
 * @export
 * @interface Chat200Response
 */
export interface Chat200Response {
    /**
     * Chat message content
     * @type {string}
     * @memberof Chat200Response
     */
    'content'?: string;
    /**
     * URL for streaming chat responses
     * @type {string}
     * @memberof Chat200Response
     */
    'stream_url'?: string;
    /**
     * ID of object to show
     * @type {string}
     * @memberof Chat200Response
     */
    'ShowObjectId'?: string;
    /**
     * Type of object to show
     * @type {string}
     * @memberof Chat200Response
     */
    'ShowObjectType'?: string;
    /**
     * Type of action to perform
     * @type {string}
     * @memberof Chat200Response
     */
    'ActionType'?: string;
    /**
     * Status message to show in the UI
     * @type {string}
     * @memberof Chat200Response
     */
    'StatusMessage'?: string;
    /**
     * Associated ID
     * @type {string}
     * @memberof Chat200Response
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface ChatHistory200Response
 */
export interface ChatHistory200Response {
    /**
     * List of chat history items
     * @type {Array<object>}
     * @memberof ChatHistory200Response
     */
    'chat_history'?: Array<object>;
    /**
     * 
     * @type {boolean}
     * @memberof ChatHistory200Response
     */
    'has_next'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ChatHistory200Response
     */
    'has_previous'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ChatHistory200Response
     */
    'first_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatHistory200Response
     */
    'last_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatHistory200Response
     */
    'sort_order'?: string;
    /**
     * 
     * @type {number}
     * @memberof ChatHistory200Response
     */
    'start_index'?: number;
    /**
     * 
     * @type {number}
     * @memberof ChatHistory200Response
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof ChatHistory200Response
     */
    'items_per_page'?: number;
}
/**
 * 
 * @export
 * @interface ChatNewList200Response
 */
export interface ChatNewList200Response {
    /**
     * Operation success status
     * @type {boolean}
     * @memberof ChatNewList200Response
     */
    'success'?: boolean;
    /**
     * UUID of the newly created chat thread
     * @type {string}
     * @memberof ChatNewList200Response
     */
    'chat_thread_id'?: string;
}
/**
 * 
 * @export
 * @interface ChatRetrieveCurrent200Response
 */
export interface ChatRetrieveCurrent200Response {
    /**
     * Chat message content
     * @type {string}
     * @memberof ChatRetrieveCurrent200Response
     */
    'content'?: string;
}
/**
 * 
 * @export
 * @interface ChatThreadDelete200Response
 */
export interface ChatThreadDelete200Response {
    /**
     * Operation success status
     * @type {boolean}
     * @memberof ChatThreadDelete200Response
     */
    'success'?: boolean;
    /**
     * Success message
     * @type {string}
     * @memberof ChatThreadDelete200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ChatThreadDelete500Response
 */
export interface ChatThreadDelete500Response {
    /**
     * Operation success status
     * @type {boolean}
     * @memberof ChatThreadDelete500Response
     */
    'success'?: boolean;
    /**
     * Error message
     * @type {string}
     * @memberof ChatThreadDelete500Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface ChatUploadFile200Response
 */
export interface ChatUploadFile200Response {
    /**
     * Upload status message
     * @type {string}
     * @memberof ChatUploadFile200Response
     */
    'message'?: string;
    /**
     * Name of the uploaded file
     * @type {string}
     * @memberof ChatUploadFile200Response
     */
    'filename'?: string;
    /**
     * Document ID of the uploaded file
     * @type {string}
     * @memberof ChatUploadFile200Response
     */
    'doc_id'?: string;
}
/**
 * 
 * @export
 * @interface Document
 */
export interface Document {
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'type'?: DocumentTypeEnum | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'body'?: string | null;
    /**
     * 
     * @type {UserField}
     * @memberof Document
     */
    'created_by'?: UserField;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'created_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'modified_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'reviewed_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'document_covering_period_start'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'document_covering_period_end'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'publishing_state'?: DocumentPublishingStateEnum;
    /**
     * Can accept either a list of program IDs (strings) or a list of objects with id field
     * @type {Array<ProgramsListInner>}
     * @memberof Document
     */
    'programs'?: Array<ProgramsListInner>;
    /**
     * 
     * @type {Array<TagsInner>}
     * @memberof Document
     */
    'tags'?: Array<TagsInner>;
    /**
     * Can accept either a list of user IDs (strings) or a list of objects with id field
     * @type {Array<UserListOfUserFieldsInner>}
     * @memberof Document
     */
    'stakeholder_users'?: Array<UserListOfUserFieldsInner>;
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'version'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'version_summary'?: string;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'image_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'original_filename'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'blob_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'datasource_type'?: string;
}

export const DocumentTypeEnum = {
    Prd: 'PRD',
    UserFile: 'USER_FILE',
    Image: 'IMAGE',
    Qbr: 'QBR',
    LiveBrief: 'LIVE_BRIEF',
    RoadmapReview: 'ROADMAP_REVIEW',
    Notes: 'NOTES',
    Other: 'OTHER'
} as const;

export type DocumentTypeEnum = typeof DocumentTypeEnum[keyof typeof DocumentTypeEnum];
export const DocumentPublishingStateEnum = {
    PendingReview: 'PENDING_REVIEW',
    Draft: 'DRAFT',
    Rejected: 'REJECTED',
    Approved: 'APPROVED',
    Published: 'PUBLISHED'
} as const;

export type DocumentPublishingStateEnum = typeof DocumentPublishingStateEnum[keyof typeof DocumentPublishingStateEnum];

/**
 * String ID for updates, object for responses
 * @export
 * @interface DocumentField
 */
export interface DocumentField {
    /**
     * Document ID
     * @type {string}
     * @memberof DocumentField
     */
    'id'?: string;
    /**
     * Document title
     * @type {string}
     * @memberof DocumentField
     */
    'title'?: string;
    /**
     * Document type
     * @type {string}
     * @memberof DocumentField
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface DocumentListFieldInner
 */
export interface DocumentListFieldInner {
    /**
     * Document ID
     * @type {string}
     * @memberof DocumentListFieldInner
     */
    'id': string;
    /**
     * Optional, only used in response
     * @type {string}
     * @memberof DocumentListFieldInner
     */
    'title'?: string;
    /**
     * Optional, only used in response
     * @type {string}
     * @memberof DocumentListFieldInner
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface DocumentPicker
 */
export interface DocumentPicker {
    /**
     * 
     * @type {string}
     * @memberof DocumentPicker
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPicker
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPicker
     */
    'summary'?: string | null;
}
/**
 * 
 * @export
 * @interface DocumentsCreateRequest
 */
export interface DocumentsCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsCreateRequest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof DocumentsCreateRequest
     */
    'body'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentsCreateRequest
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof DocumentsCreateRequest
     */
    'publishing_state'?: DocumentsCreateRequestPublishingStateEnum;
    /**
     * 
     * @type {string}
     * @memberof DocumentsCreateRequest
     */
    'document_covering_period_start'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentsCreateRequest
     */
    'document_covering_period_end'?: string;
    /**
     * List of tags
     * @type {Array<string>}
     * @memberof DocumentsCreateRequest
     */
    'tags'?: Array<string>;
    /**
     * List of stakeholder user emails or UUIDs
     * @type {Array<string>}
     * @memberof DocumentsCreateRequest
     */
    'stakeholder_users'?: Array<string>;
    /**
     * Program UUID
     * @type {string}
     * @memberof DocumentsCreateRequest
     */
    'program'?: string;
}

export const DocumentsCreateRequestPublishingStateEnum = {
    PendingReview: 'PENDING_REVIEW',
    Draft: 'DRAFT',
    Rejected: 'REJECTED',
    Approved: 'APPROVED',
    Published: 'PUBLISHED'
} as const;

export type DocumentsCreateRequestPublishingStateEnum = typeof DocumentsCreateRequestPublishingStateEnum[keyof typeof DocumentsCreateRequestPublishingStateEnum];

/**
 * 
 * @export
 * @interface Goal
 */
export interface Goal {
    /**
     * 
     * @type {string}
     * @memberof Goal
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Goal
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Goal
     */
    'goal_language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Goal
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Goal
     */
    'why_it_matters'?: string | null;
    /**
     * Can accept either a list of document IDs (strings) or a list of objects with id field
     * @type {Array<DocumentListFieldInner>}
     * @memberof Goal
     */
    'prd'?: Array<DocumentListFieldInner>;
    /**
     * 
     * @type {string}
     * @memberof Goal
     */
    'created_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Goal
     */
    'modified_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Goal
     */
    'original_due_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Goal
     */
    'current_due_date'?: string | null;
    /**
     * Can accept either a list of user IDs (strings) or a list of objects with id field
     * @type {Array<UserListOfUserFieldsInner>}
     * @memberof Goal
     */
    'owner_users'?: Array<UserListOfUserFieldsInner>;
    /**
     * Can accept either a list of program IDs (strings) or a list of objects with id field
     * @type {Array<ProgramsListInner>}
     * @memberof Goal
     */
    'programs'?: Array<ProgramsListInner>;
    /**
     * Can accept either a list of user IDs (strings) or a list of objects with id field
     * @type {Array<UserListOfUserFieldsInner>}
     * @memberof Goal
     */
    'stakeholder_users'?: Array<UserListOfUserFieldsInner>;
    /**
     * 
     * @type {Array<TagsInner>}
     * @memberof Goal
     */
    'tags'?: Array<TagsInner>;
    /**
     * 
     * @type {number}
     * @memberof Goal
     */
    'version'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Goal
     */
    'version_summary'?: string;
    /**
     * 
     * @type {UserField}
     * @memberof Goal
     */
    'created_by'?: UserField;
    /**
     * 
     * @type {Status1}
     * @memberof Goal
     */
    'status'?: Status1;
}
/**
 * 
 * @export
 * @interface GoalBase
 */
export interface GoalBase {
    /**
     * 
     * @type {string}
     * @memberof GoalBase
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GoalBase
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GoalBase
     */
    'goal_language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoalBase
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface GoalPicker
 */
export interface GoalPicker {
    /**
     * 
     * @type {string}
     * @memberof GoalPicker
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GoalPicker
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GoalPicker
     */
    'goal_language'?: string | null;
}
/**
 * 
 * @export
 * @interface GoogleDocsWebhook200Response
 */
export interface GoogleDocsWebhook200Response {
    /**
     * Status of the webhook processing
     * @type {string}
     * @memberof GoogleDocsWebhook200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface JiraSyncDocumentsCreateRequest
 */
export interface JiraSyncDocumentsCreateRequest {
    /**
     * Whether to enable or disable Jira sync
     * @type {boolean}
     * @memberof JiraSyncDocumentsCreateRequest
     */
    'sync_enabled': boolean;
}
/**
 * 
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface Program
 */
export interface Program {
    /**
     * 
     * @type {string}
     * @memberof Program
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Program
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Program
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Program
     */
    'mission'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Program
     */
    'charter'?: string | null;
    /**
     * Can accept either a list of user IDs (strings) or a list of objects with id field
     * @type {Array<UserListOfUserFieldsInner>}
     * @memberof Program
     */
    'principal_users'?: Array<UserListOfUserFieldsInner>;
    /**
     * Can accept either a list of user IDs (strings) or a list of objects with id field
     * @type {Array<UserListOfUserFieldsInner>}
     * @memberof Program
     */
    'stakeholder_users'?: Array<UserListOfUserFieldsInner>;
    /**
     * 
     * @type {string}
     * @memberof Program
     */
    'parent'?: string | null;
    /**
     * 
     * @type {Array<TagsInner>}
     * @memberof Program
     */
    'tags'?: Array<TagsInner>;
    /**
     * 
     * @type {UserField}
     * @memberof Program
     */
    'created_by'?: UserField;
    /**
     * 
     * @type {string}
     * @memberof Program
     */
    'created_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Program
     */
    'modified_date'?: string | null;
}
/**
 * 
 * @export
 * @interface ProgramPicker
 */
export interface ProgramPicker {
    /**
     * 
     * @type {string}
     * @memberof ProgramPicker
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramPicker
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramPicker
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface ProgramsListInner
 */
export interface ProgramsListInner {
    /**
     * Program ID
     * @type {string}
     * @memberof ProgramsListInner
     */
    'id': string;
    /**
     * Optional, only used in response
     * @type {string}
     * @memberof ProgramsListInner
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface PublishDocAsEpicRequest
 */
export interface PublishDocAsEpicRequest {
    /**
     * Program ID to use for publishing (required if document is associated with multiple programs)
     * @type {string}
     * @memberof PublishDocAsEpicRequest
     */
    'program_id'?: string;
}
/**
 * 
 * @export
 * @interface RegisterGoogleDoc200Response
 */
export interface RegisterGoogleDoc200Response {
    /**
     * Success message
     * @type {string}
     * @memberof RegisterGoogleDoc200Response
     */
    'message'?: string;
    /**
     * ID of the created or existing document
     * @type {string}
     * @memberof RegisterGoogleDoc200Response
     */
    'document_id'?: string;
    /**
     * Document title
     * @type {string}
     * @memberof RegisterGoogleDoc200Response
     */
    'title'?: string;
    /**
     * Whether the document was already registered
     * @type {boolean}
     * @memberof RegisterGoogleDoc200Response
     */
    'already_registered'?: boolean;
}
/**
 * 
 * @export
 * @interface RegisterGoogleDocRequest
 */
export interface RegisterGoogleDocRequest {
    /**
     * Google Doc ID to register
     * @type {string}
     * @memberof RegisterGoogleDocRequest
     */
    'google_doc_id': string;
}
/**
 * 
 * @export
 * @interface Status
 */
export interface Status {
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'goal': string;
    /**
     * 
     * @type {GoalBase}
     * @memberof Status
     */
    'goal_details'?: GoalBase;
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'status'?: StatusStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'status_display'?: string;
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'status_note'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'path_to_green'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'publishing_state'?: StatusPublishingStateEnum;
    /**
     * 
     * @type {UserField}
     * @memberof Status
     */
    'created_by'?: UserField;
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'created_date'?: string;
}

export const StatusStatusEnum = {
    Red: 'RED',
    Yellow: 'YELLOW',
    Green: 'GREEN',
    NotStarted: 'NOT_STARTED',
    InProgress: 'IN_PROGRESS',
    InReview: 'IN_REVIEW',
    Completed: 'COMPLETED',
    CompletedLate: 'COMPLETED_LATE',
    Cancelled: 'CANCELLED',
    Deferred: 'DEFERRED',
    Deleted: 'DELETED'
} as const;

export type StatusStatusEnum = typeof StatusStatusEnum[keyof typeof StatusStatusEnum];
export const StatusPublishingStateEnum = {
    PendingReview: 'PENDING_REVIEW',
    Draft: 'DRAFT',
    Rejected: 'REJECTED',
    Approved: 'APPROVED',
    Published: 'PUBLISHED'
} as const;

export type StatusPublishingStateEnum = typeof StatusPublishingStateEnum[keyof typeof StatusPublishingStateEnum];

/**
 * 
 * @export
 * @interface Status1
 */
export interface Status1 {
    /**
     * 
     * @type {string}
     * @memberof Status1
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Status1
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof Status1
     */
    'status_display'?: string;
    /**
     * 
     * @type {string}
     * @memberof Status1
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface StatusCreateRequest
 */
export interface StatusCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof StatusCreateRequest
     */
    'goal': string;
    /**
     * 
     * @type {string}
     * @memberof StatusCreateRequest
     */
    'status': StatusCreateRequestStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof StatusCreateRequest
     */
    'date'?: string;
    /**
     * 
     * @type {string}
     * @memberof StatusCreateRequest
     */
    'status_note'?: string;
    /**
     * 
     * @type {string}
     * @memberof StatusCreateRequest
     */
    'path_to_green'?: string;
    /**
     * 
     * @type {string}
     * @memberof StatusCreateRequest
     */
    'publishing_state'?: StatusCreateRequestPublishingStateEnum;
}

export const StatusCreateRequestStatusEnum = {
    Red: 'RED',
    Yellow: 'YELLOW',
    Green: 'GREEN',
    NotStarted: 'NOT_STARTED',
    InProgress: 'IN_PROGRESS',
    InReview: 'IN_REVIEW',
    Completed: 'COMPLETED',
    CompletedLate: 'COMPLETED_LATE',
    Cancelled: 'CANCELLED',
    Deferred: 'DEFERRED',
    Deleted: 'DELETED'
} as const;

export type StatusCreateRequestStatusEnum = typeof StatusCreateRequestStatusEnum[keyof typeof StatusCreateRequestStatusEnum];
export const StatusCreateRequestPublishingStateEnum = {
    PendingReview: 'PENDING_REVIEW',
    Draft: 'DRAFT',
    Rejected: 'REJECTED',
    Approved: 'APPROVED',
    Published: 'PUBLISHED'
} as const;

export type StatusCreateRequestPublishingStateEnum = typeof StatusCreateRequestPublishingStateEnum[keyof typeof StatusCreateRequestPublishingStateEnum];

/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'tag': string;
    /**
     * 
     * @type {boolean}
     * @memberof Tag
     */
    'archived'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'created_date'?: string | null;
}
/**
 * 
 * @export
 * @interface TagsInner
 */
export interface TagsInner {
    /**
     * 
     * @type {string}
     * @memberof TagsInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TagsInner
     */
    'tag'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'last_name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'is_staff'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'date_joined'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'last_login'?: string;
    /**
     * 
     * @type {Organization}
     * @memberof User
     */
    'organization'?: Organization;
    /**
     * 
     * @type {Address}
     * @memberof User
     */
    'address'?: Address;
    /**
     * 
     * @type {object}
     * @memberof User
     */
    'user_facts'?: object;
    /**
     * 
     * @type {object}
     * @memberof User
     */
    'walkthrough_status'?: object;
}
/**
 * 
 * @export
 * @interface UserField
 */
export interface UserField {
    /**
     * 
     * @type {string}
     * @memberof UserField
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserField
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserField
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserField
     */
    'last_name'?: string;
}
/**
 * 
 * @export
 * @interface UserListOfUserFieldsInner
 */
export interface UserListOfUserFieldsInner {
    /**
     * User ID
     * @type {string}
     * @memberof UserListOfUserFieldsInner
     */
    'id': string;
    /**
     * Optional, only used in response
     * @type {string}
     * @memberof UserListOfUserFieldsInner
     */
    'email'?: string;
    /**
     * Optional, only used in response
     * @type {string}
     * @memberof UserListOfUserFieldsInner
     */
    'first_name'?: string;
    /**
     * Optional, only used in response
     * @type {string}
     * @memberof UserListOfUserFieldsInner
     */
    'last_name'?: string;
}
/**
 * 
 * @export
 * @interface UserStory
 */
export interface UserStory {
    /**
     * 
     * @type {string}
     * @memberof UserStory
     */
    'id'?: string;
    /**
     * 
     * @type {DocumentField}
     * @memberof UserStory
     */
    'prd'?: DocumentField | null;
    /**
     * 
     * @type {string}
     * @memberof UserStory
     */
    'as_a'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserStory
     */
    'i_want_to'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserStory
     */
    'so_that'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserStory
     */
    'freetext_override'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserStory
     */
    'acceptance_criteria'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserStory
     */
    'created_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserStory
     */
    'modified_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserStory
     */
    'due_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserStory
     */
    'status'?: UserStoryStatusEnum;
    /**
     * Priority of the user story in Jira
     * @type {string}
     * @memberof UserStory
     */
    'priority'?: string | null;
    /**
     * 
     * @type {Array<TagsInner>}
     * @memberof UserStory
     */
    'tags'?: Array<TagsInner>;
    /**
     * 
     * @type {UserField}
     * @memberof UserStory
     */
    'created_by'?: UserField;
}

export const UserStoryStatusEnum = {
    Red: 'RED',
    Yellow: 'YELLOW',
    Green: 'GREEN',
    NotStarted: 'NOT_STARTED',
    InProgress: 'IN_PROGRESS',
    InReview: 'IN_REVIEW',
    Completed: 'COMPLETED',
    CompletedLate: 'COMPLETED_LATE',
    Cancelled: 'CANCELLED',
    Deferred: 'DEFERRED',
    Deleted: 'DELETED'
} as const;

export type UserStoryStatusEnum = typeof UserStoryStatusEnum[keyof typeof UserStoryStatusEnum];

/**
 * 
 * @export
 * @interface UserstoriesCreateRequest
 */
export interface UserstoriesCreateRequest {
    /**
     * PRD UUID
     * @type {string}
     * @memberof UserstoriesCreateRequest
     */
    'prd': string;
    /**
     * 
     * @type {string}
     * @memberof UserstoriesCreateRequest
     */
    'as_a'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserstoriesCreateRequest
     */
    'i_want_to'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserstoriesCreateRequest
     */
    'so_that'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserstoriesCreateRequest
     */
    'freetext_override'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserstoriesCreateRequest
     */
    'acceptance_criteria'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserstoriesCreateRequest
     */
    'due_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserstoriesCreateRequest
     */
    'status'?: UserstoriesCreateRequestStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UserstoriesCreateRequest
     */
    'priority'?: string;
    /**
     * List of tag UUIDs
     * @type {Array<string>}
     * @memberof UserstoriesCreateRequest
     */
    'tags'?: Array<string>;
}

export const UserstoriesCreateRequestStatusEnum = {
    Red: 'RED',
    Yellow: 'YELLOW',
    Green: 'GREEN',
    NotStarted: 'NOT_STARTED',
    InProgress: 'IN_PROGRESS',
    InReview: 'IN_REVIEW',
    Completed: 'COMPLETED',
    CompletedLate: 'COMPLETED_LATE',
    Cancelled: 'CANCELLED',
    Deferred: 'DEFERRED',
    Deleted: 'DELETED'
} as const;

export type UserstoriesCreateRequestStatusEnum = typeof UserstoriesCreateRequestStatusEnum[keyof typeof UserstoriesCreateRequestStatusEnum];

/**
 * 
 * @export
 * @interface WatchGoogleDoc200Response
 */
export interface WatchGoogleDoc200Response {
    /**
     * Watch response from Google API
     * @type {object}
     * @memberof WatchGoogleDoc200Response
     */
    'watch'?: object;
}

/**
 * ChatApi - axios parameter creator
 * @export
 */
export const ChatApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Process chat message
         * @param {number} [page] A page number within the paginated result set.
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [xCallerID] Optional ID of the application calling the ID, used in conjunction with the caller_thread_id
         * @param {string} [xCallerThreadID] Caller-side thread ID used in conjunction with the caller_id to identify the conversation that this message is a part of. This will be looked up against the internal thread id in Product Partner.
         * @param {string} [msg] Chat message
         * @param {string} [docIds] Document IDs to reference
         * @param {string} [action] Action
         * @param {boolean} [stream] Stream the response
         * @param {string} [responseFormat] Response format (html or text)
         * @param {string} [callerType] Caller type, such as \&#39;FREE_CHAT\&#39; or \&#39;CHAT\&#39; or \&#39;COMMENT\&#39; or \&#39;EMAIL\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chat: async (page?: number, xUserID?: string, xCallerID?: string, xCallerThreadID?: string, msg?: string, docIds?: string, action?: string, stream?: boolean, responseFormat?: string, callerType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chat/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (msg !== undefined) {
                localVarQueryParameter['msg'] = msg;
            }

            if (docIds !== undefined) {
                localVarQueryParameter['doc_ids'] = docIds;
            }

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            if (stream !== undefined) {
                localVarQueryParameter['stream'] = stream;
            }

            if (responseFormat !== undefined) {
                localVarQueryParameter['response_format'] = responseFormat;
            }

            if (callerType !== undefined) {
                localVarQueryParameter['caller_type'] = callerType;
            }


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            if (xCallerID != null) {
                localVarHeaderParameter['X-Caller-ID'] = String(xCallerID);
            }
            if (xCallerThreadID != null) {
                localVarHeaderParameter['X-Caller-Thread-ID'] = String(xCallerThreadID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get chat history
         * @param {number} [page] Page number
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [xCallerID] Optional ID of the application calling the ID, used in conjunction with the caller_thread_id
         * @param {string} [xCallerThreadID] Caller-side thread ID used in conjunction with the caller_id to identify the conversation that this message is a part of. This will be looked up against the internal thread id in Product Partner.
         * @param {string} [lastCreatedDate] Last created date
         * @param {string} [sortOrder] Sort order (asc/desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatHistory: async (page?: number, xUserID?: string, xCallerID?: string, xCallerThreadID?: string, lastCreatedDate?: string, sortOrder?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chat/history/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (lastCreatedDate !== undefined) {
                localVarQueryParameter['last_created_date'] = lastCreatedDate;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            if (xCallerID != null) {
                localVarHeaderParameter['X-Caller-ID'] = String(xCallerID);
            }
            if (xCallerThreadID != null) {
                localVarHeaderParameter['X-Caller-Thread-ID'] = String(xCallerThreadID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new chat thread and return its ID
         * @summary Create a new chat thread
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [xCallerID] Optional ID of the application calling the API, used in conjunction with the caller_thread_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatNewList: async (xUserID?: string, xCallerID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chat/new/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            if (xCallerID != null) {
                localVarHeaderParameter['X-Caller-ID'] = String(xCallerID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current chat thread from the session.
         * @param {number} [page] A page number within the paginated result set.
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [xCallerID] Optional ID of the application calling the ID, used in conjunction with the caller_thread_id
         * @param {string} [xCallerThreadID] Caller-side thread ID used in conjunction with the caller_id to identify the conversation that this message is a part of. This will be looked up against the internal thread id in Product Partner.
         * @param {string} [messageFormat] Format for messages (html or none)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatRetrieveCurrent: async (page?: number, xUserID?: string, xCallerID?: string, xCallerThreadID?: string, messageFormat?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chat/thread/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (messageFormat !== undefined) {
                localVarQueryParameter['message_format'] = messageFormat;
            }


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            if (xCallerID != null) {
                localVarHeaderParameter['X-Caller-ID'] = String(xCallerID);
            }
            if (xCallerThreadID != null) {
                localVarHeaderParameter['X-Caller-Thread-ID'] = String(xCallerThreadID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a chat thread and all its messages from Firestore
         * @param {string} threadId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatThreadDelete: async (threadId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('chatThreadDelete', 'threadId', threadId)
            const localVarPath = `/chat/thread/{thread_id}/`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific chat thread by ID.
         * @param {string} threadId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [xCallerID] Optional ID of the application calling the ID, used in conjunction with the caller_thread_id
         * @param {string} [xCallerThreadID] Caller-side thread ID used in conjunction with the caller_id to identify the conversation that this message is a part of. This will be looked up against the internal thread id in Product Partner.
         * @param {string} [messageFormat] Format for messages (html or none)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatThreadRead: async (threadId: string, xUserID?: string, xCallerID?: string, xCallerThreadID?: string, messageFormat?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('chatThreadRead', 'threadId', threadId)
            const localVarPath = `/chat/thread/{thread_id}/`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (messageFormat !== undefined) {
                localVarQueryParameter['message_format'] = messageFormat;
            }


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            if (xCallerID != null) {
                localVarHeaderParameter['X-Caller-ID'] = String(xCallerID);
            }
            if (xCallerThreadID != null) {
                localVarHeaderParameter['X-Caller-Thread-ID'] = String(xCallerThreadID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a file
         * @param {File} file 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [xCallerID] Optional ID of the application calling the ID, used in conjunction with the caller_thread_id
         * @param {string} [xCallerThreadID] Caller-side thread ID used in conjunction with the caller_id to identify the conversation that this message is a part of. This will be looked up against the internal thread id in Product Partner.
         * @param {string} [filename] 
         * @param {string} [contentType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatUploadFile: async (file: File, xUserID?: string, xCallerID?: string, xCallerThreadID?: string, filename?: string, contentType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('chatUploadFile', 'file', file)
            const localVarPath = `/chat/upload/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (filename !== undefined) { 
                localVarFormParams.append('filename', filename as any);
            }
    
            if (contentType !== undefined) { 
                localVarFormParams.append('content_type', contentType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            if (xCallerID != null) {
                localVarHeaderParameter['X-Caller-ID'] = String(xCallerID);
            }
            if (xCallerThreadID != null) {
                localVarHeaderParameter['X-Caller-Thread-ID'] = String(xCallerThreadID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatApi - functional programming interface
 * @export
 */
export const ChatApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatApiAxiosParamCreator(configuration)
    return {
        /**
         * Process chat message
         * @param {number} [page] A page number within the paginated result set.
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [xCallerID] Optional ID of the application calling the ID, used in conjunction with the caller_thread_id
         * @param {string} [xCallerThreadID] Caller-side thread ID used in conjunction with the caller_id to identify the conversation that this message is a part of. This will be looked up against the internal thread id in Product Partner.
         * @param {string} [msg] Chat message
         * @param {string} [docIds] Document IDs to reference
         * @param {string} [action] Action
         * @param {boolean} [stream] Stream the response
         * @param {string} [responseFormat] Response format (html or text)
         * @param {string} [callerType] Caller type, such as \&#39;FREE_CHAT\&#39; or \&#39;CHAT\&#39; or \&#39;COMMENT\&#39; or \&#39;EMAIL\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chat(page?: number, xUserID?: string, xCallerID?: string, xCallerThreadID?: string, msg?: string, docIds?: string, action?: string, stream?: boolean, responseFormat?: string, callerType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Chat200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chat(page, xUserID, xCallerID, xCallerThreadID, msg, docIds, action, stream, responseFormat, callerType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.chat']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get chat history
         * @param {number} [page] Page number
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [xCallerID] Optional ID of the application calling the ID, used in conjunction with the caller_thread_id
         * @param {string} [xCallerThreadID] Caller-side thread ID used in conjunction with the caller_id to identify the conversation that this message is a part of. This will be looked up against the internal thread id in Product Partner.
         * @param {string} [lastCreatedDate] Last created date
         * @param {string} [sortOrder] Sort order (asc/desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatHistory(page?: number, xUserID?: string, xCallerID?: string, xCallerThreadID?: string, lastCreatedDate?: string, sortOrder?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatHistory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatHistory(page, xUserID, xCallerID, xCallerThreadID, lastCreatedDate, sortOrder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.chatHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new chat thread and return its ID
         * @summary Create a new chat thread
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [xCallerID] Optional ID of the application calling the API, used in conjunction with the caller_thread_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatNewList(xUserID?: string, xCallerID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatNewList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatNewList(xUserID, xCallerID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.chatNewList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the current chat thread from the session.
         * @param {number} [page] A page number within the paginated result set.
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [xCallerID] Optional ID of the application calling the ID, used in conjunction with the caller_thread_id
         * @param {string} [xCallerThreadID] Caller-side thread ID used in conjunction with the caller_id to identify the conversation that this message is a part of. This will be looked up against the internal thread id in Product Partner.
         * @param {string} [messageFormat] Format for messages (html or none)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatRetrieveCurrent(page?: number, xUserID?: string, xCallerID?: string, xCallerThreadID?: string, messageFormat?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatRetrieveCurrent200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatRetrieveCurrent(page, xUserID, xCallerID, xCallerThreadID, messageFormat, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.chatRetrieveCurrent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a chat thread and all its messages from Firestore
         * @param {string} threadId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatThreadDelete(threadId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatThreadDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatThreadDelete(threadId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.chatThreadDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific chat thread by ID.
         * @param {string} threadId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [xCallerID] Optional ID of the application calling the ID, used in conjunction with the caller_thread_id
         * @param {string} [xCallerThreadID] Caller-side thread ID used in conjunction with the caller_id to identify the conversation that this message is a part of. This will be looked up against the internal thread id in Product Partner.
         * @param {string} [messageFormat] Format for messages (html or none)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatThreadRead(threadId: string, xUserID?: string, xCallerID?: string, xCallerThreadID?: string, messageFormat?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatRetrieveCurrent200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatThreadRead(threadId, xUserID, xCallerID, xCallerThreadID, messageFormat, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.chatThreadRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload a file
         * @param {File} file 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [xCallerID] Optional ID of the application calling the ID, used in conjunction with the caller_thread_id
         * @param {string} [xCallerThreadID] Caller-side thread ID used in conjunction with the caller_id to identify the conversation that this message is a part of. This will be looked up against the internal thread id in Product Partner.
         * @param {string} [filename] 
         * @param {string} [contentType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatUploadFile(file: File, xUserID?: string, xCallerID?: string, xCallerThreadID?: string, filename?: string, contentType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatUploadFile200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatUploadFile(file, xUserID, xCallerID, xCallerThreadID, filename, contentType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.chatUploadFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChatApi - factory interface
 * @export
 */
export const ChatApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatApiFp(configuration)
    return {
        /**
         * Process chat message
         * @param {number} [page] A page number within the paginated result set.
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [xCallerID] Optional ID of the application calling the ID, used in conjunction with the caller_thread_id
         * @param {string} [xCallerThreadID] Caller-side thread ID used in conjunction with the caller_id to identify the conversation that this message is a part of. This will be looked up against the internal thread id in Product Partner.
         * @param {string} [msg] Chat message
         * @param {string} [docIds] Document IDs to reference
         * @param {string} [action] Action
         * @param {boolean} [stream] Stream the response
         * @param {string} [responseFormat] Response format (html or text)
         * @param {string} [callerType] Caller type, such as \&#39;FREE_CHAT\&#39; or \&#39;CHAT\&#39; or \&#39;COMMENT\&#39; or \&#39;EMAIL\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chat(page?: number, xUserID?: string, xCallerID?: string, xCallerThreadID?: string, msg?: string, docIds?: string, action?: string, stream?: boolean, responseFormat?: string, callerType?: string, options?: RawAxiosRequestConfig): AxiosPromise<Chat200Response> {
            return localVarFp.chat(page, xUserID, xCallerID, xCallerThreadID, msg, docIds, action, stream, responseFormat, callerType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get chat history
         * @param {number} [page] Page number
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [xCallerID] Optional ID of the application calling the ID, used in conjunction with the caller_thread_id
         * @param {string} [xCallerThreadID] Caller-side thread ID used in conjunction with the caller_id to identify the conversation that this message is a part of. This will be looked up against the internal thread id in Product Partner.
         * @param {string} [lastCreatedDate] Last created date
         * @param {string} [sortOrder] Sort order (asc/desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatHistory(page?: number, xUserID?: string, xCallerID?: string, xCallerThreadID?: string, lastCreatedDate?: string, sortOrder?: string, options?: RawAxiosRequestConfig): AxiosPromise<ChatHistory200Response> {
            return localVarFp.chatHistory(page, xUserID, xCallerID, xCallerThreadID, lastCreatedDate, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new chat thread and return its ID
         * @summary Create a new chat thread
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [xCallerID] Optional ID of the application calling the API, used in conjunction with the caller_thread_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatNewList(xUserID?: string, xCallerID?: string, options?: RawAxiosRequestConfig): AxiosPromise<ChatNewList200Response> {
            return localVarFp.chatNewList(xUserID, xCallerID, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current chat thread from the session.
         * @param {number} [page] A page number within the paginated result set.
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [xCallerID] Optional ID of the application calling the ID, used in conjunction with the caller_thread_id
         * @param {string} [xCallerThreadID] Caller-side thread ID used in conjunction with the caller_id to identify the conversation that this message is a part of. This will be looked up against the internal thread id in Product Partner.
         * @param {string} [messageFormat] Format for messages (html or none)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatRetrieveCurrent(page?: number, xUserID?: string, xCallerID?: string, xCallerThreadID?: string, messageFormat?: string, options?: RawAxiosRequestConfig): AxiosPromise<ChatRetrieveCurrent200Response> {
            return localVarFp.chatRetrieveCurrent(page, xUserID, xCallerID, xCallerThreadID, messageFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a chat thread and all its messages from Firestore
         * @param {string} threadId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatThreadDelete(threadId: string, options?: RawAxiosRequestConfig): AxiosPromise<ChatThreadDelete200Response> {
            return localVarFp.chatThreadDelete(threadId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific chat thread by ID.
         * @param {string} threadId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [xCallerID] Optional ID of the application calling the ID, used in conjunction with the caller_thread_id
         * @param {string} [xCallerThreadID] Caller-side thread ID used in conjunction with the caller_id to identify the conversation that this message is a part of. This will be looked up against the internal thread id in Product Partner.
         * @param {string} [messageFormat] Format for messages (html or none)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatThreadRead(threadId: string, xUserID?: string, xCallerID?: string, xCallerThreadID?: string, messageFormat?: string, options?: RawAxiosRequestConfig): AxiosPromise<ChatRetrieveCurrent200Response> {
            return localVarFp.chatThreadRead(threadId, xUserID, xCallerID, xCallerThreadID, messageFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a file
         * @param {File} file 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [xCallerID] Optional ID of the application calling the ID, used in conjunction with the caller_thread_id
         * @param {string} [xCallerThreadID] Caller-side thread ID used in conjunction with the caller_id to identify the conversation that this message is a part of. This will be looked up against the internal thread id in Product Partner.
         * @param {string} [filename] 
         * @param {string} [contentType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatUploadFile(file: File, xUserID?: string, xCallerID?: string, xCallerThreadID?: string, filename?: string, contentType?: string, options?: RawAxiosRequestConfig): AxiosPromise<ChatUploadFile200Response> {
            return localVarFp.chatUploadFile(file, xUserID, xCallerID, xCallerThreadID, filename, contentType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChatApi - interface
 * @export
 * @interface ChatApi
 */
export interface ChatApiInterface {
    /**
     * Process chat message
     * @param {number} [page] A page number within the paginated result set.
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {string} [xCallerID] Optional ID of the application calling the ID, used in conjunction with the caller_thread_id
     * @param {string} [xCallerThreadID] Caller-side thread ID used in conjunction with the caller_id to identify the conversation that this message is a part of. This will be looked up against the internal thread id in Product Partner.
     * @param {string} [msg] Chat message
     * @param {string} [docIds] Document IDs to reference
     * @param {string} [action] Action
     * @param {boolean} [stream] Stream the response
     * @param {string} [responseFormat] Response format (html or text)
     * @param {string} [callerType] Caller type, such as \&#39;FREE_CHAT\&#39; or \&#39;CHAT\&#39; or \&#39;COMMENT\&#39; or \&#39;EMAIL\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    chat(page?: number, xUserID?: string, xCallerID?: string, xCallerThreadID?: string, msg?: string, docIds?: string, action?: string, stream?: boolean, responseFormat?: string, callerType?: string, options?: RawAxiosRequestConfig): AxiosPromise<Chat200Response>;

    /**
     * Get chat history
     * @param {number} [page] Page number
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {string} [xCallerID] Optional ID of the application calling the ID, used in conjunction with the caller_thread_id
     * @param {string} [xCallerThreadID] Caller-side thread ID used in conjunction with the caller_id to identify the conversation that this message is a part of. This will be looked up against the internal thread id in Product Partner.
     * @param {string} [lastCreatedDate] Last created date
     * @param {string} [sortOrder] Sort order (asc/desc)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    chatHistory(page?: number, xUserID?: string, xCallerID?: string, xCallerThreadID?: string, lastCreatedDate?: string, sortOrder?: string, options?: RawAxiosRequestConfig): AxiosPromise<ChatHistory200Response>;

    /**
     * Create a new chat thread and return its ID
     * @summary Create a new chat thread
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {string} [xCallerID] Optional ID of the application calling the API, used in conjunction with the caller_thread_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    chatNewList(xUserID?: string, xCallerID?: string, options?: RawAxiosRequestConfig): AxiosPromise<ChatNewList200Response>;

    /**
     * Get the current chat thread from the session.
     * @param {number} [page] A page number within the paginated result set.
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {string} [xCallerID] Optional ID of the application calling the ID, used in conjunction with the caller_thread_id
     * @param {string} [xCallerThreadID] Caller-side thread ID used in conjunction with the caller_id to identify the conversation that this message is a part of. This will be looked up against the internal thread id in Product Partner.
     * @param {string} [messageFormat] Format for messages (html or none)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    chatRetrieveCurrent(page?: number, xUserID?: string, xCallerID?: string, xCallerThreadID?: string, messageFormat?: string, options?: RawAxiosRequestConfig): AxiosPromise<ChatRetrieveCurrent200Response>;

    /**
     * Delete a chat thread and all its messages from Firestore
     * @param {string} threadId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    chatThreadDelete(threadId: string, options?: RawAxiosRequestConfig): AxiosPromise<ChatThreadDelete200Response>;

    /**
     * Get a specific chat thread by ID.
     * @param {string} threadId 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {string} [xCallerID] Optional ID of the application calling the ID, used in conjunction with the caller_thread_id
     * @param {string} [xCallerThreadID] Caller-side thread ID used in conjunction with the caller_id to identify the conversation that this message is a part of. This will be looked up against the internal thread id in Product Partner.
     * @param {string} [messageFormat] Format for messages (html or none)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    chatThreadRead(threadId: string, xUserID?: string, xCallerID?: string, xCallerThreadID?: string, messageFormat?: string, options?: RawAxiosRequestConfig): AxiosPromise<ChatRetrieveCurrent200Response>;

    /**
     * Upload a file
     * @param {File} file 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {string} [xCallerID] Optional ID of the application calling the ID, used in conjunction with the caller_thread_id
     * @param {string} [xCallerThreadID] Caller-side thread ID used in conjunction with the caller_id to identify the conversation that this message is a part of. This will be looked up against the internal thread id in Product Partner.
     * @param {string} [filename] 
     * @param {string} [contentType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    chatUploadFile(file: File, xUserID?: string, xCallerID?: string, xCallerThreadID?: string, filename?: string, contentType?: string, options?: RawAxiosRequestConfig): AxiosPromise<ChatUploadFile200Response>;

}

/**
 * ChatApi - object-oriented interface
 * @export
 * @class ChatApi
 * @extends {BaseAPI}
 */
export class ChatApi extends BaseAPI implements ChatApiInterface {
    /**
     * Process chat message
     * @param {number} [page] A page number within the paginated result set.
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {string} [xCallerID] Optional ID of the application calling the ID, used in conjunction with the caller_thread_id
     * @param {string} [xCallerThreadID] Caller-side thread ID used in conjunction with the caller_id to identify the conversation that this message is a part of. This will be looked up against the internal thread id in Product Partner.
     * @param {string} [msg] Chat message
     * @param {string} [docIds] Document IDs to reference
     * @param {string} [action] Action
     * @param {boolean} [stream] Stream the response
     * @param {string} [responseFormat] Response format (html or text)
     * @param {string} [callerType] Caller type, such as \&#39;FREE_CHAT\&#39; or \&#39;CHAT\&#39; or \&#39;COMMENT\&#39; or \&#39;EMAIL\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public chat(page?: number, xUserID?: string, xCallerID?: string, xCallerThreadID?: string, msg?: string, docIds?: string, action?: string, stream?: boolean, responseFormat?: string, callerType?: string, options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).chat(page, xUserID, xCallerID, xCallerThreadID, msg, docIds, action, stream, responseFormat, callerType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get chat history
     * @param {number} [page] Page number
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {string} [xCallerID] Optional ID of the application calling the ID, used in conjunction with the caller_thread_id
     * @param {string} [xCallerThreadID] Caller-side thread ID used in conjunction with the caller_id to identify the conversation that this message is a part of. This will be looked up against the internal thread id in Product Partner.
     * @param {string} [lastCreatedDate] Last created date
     * @param {string} [sortOrder] Sort order (asc/desc)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public chatHistory(page?: number, xUserID?: string, xCallerID?: string, xCallerThreadID?: string, lastCreatedDate?: string, sortOrder?: string, options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).chatHistory(page, xUserID, xCallerID, xCallerThreadID, lastCreatedDate, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new chat thread and return its ID
     * @summary Create a new chat thread
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {string} [xCallerID] Optional ID of the application calling the API, used in conjunction with the caller_thread_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public chatNewList(xUserID?: string, xCallerID?: string, options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).chatNewList(xUserID, xCallerID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current chat thread from the session.
     * @param {number} [page] A page number within the paginated result set.
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {string} [xCallerID] Optional ID of the application calling the ID, used in conjunction with the caller_thread_id
     * @param {string} [xCallerThreadID] Caller-side thread ID used in conjunction with the caller_id to identify the conversation that this message is a part of. This will be looked up against the internal thread id in Product Partner.
     * @param {string} [messageFormat] Format for messages (html or none)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public chatRetrieveCurrent(page?: number, xUserID?: string, xCallerID?: string, xCallerThreadID?: string, messageFormat?: string, options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).chatRetrieveCurrent(page, xUserID, xCallerID, xCallerThreadID, messageFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a chat thread and all its messages from Firestore
     * @param {string} threadId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public chatThreadDelete(threadId: string, options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).chatThreadDelete(threadId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific chat thread by ID.
     * @param {string} threadId 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {string} [xCallerID] Optional ID of the application calling the ID, used in conjunction with the caller_thread_id
     * @param {string} [xCallerThreadID] Caller-side thread ID used in conjunction with the caller_id to identify the conversation that this message is a part of. This will be looked up against the internal thread id in Product Partner.
     * @param {string} [messageFormat] Format for messages (html or none)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public chatThreadRead(threadId: string, xUserID?: string, xCallerID?: string, xCallerThreadID?: string, messageFormat?: string, options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).chatThreadRead(threadId, xUserID, xCallerID, xCallerThreadID, messageFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a file
     * @param {File} file 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {string} [xCallerID] Optional ID of the application calling the ID, used in conjunction with the caller_thread_id
     * @param {string} [xCallerThreadID] Caller-side thread ID used in conjunction with the caller_id to identify the conversation that this message is a part of. This will be looked up against the internal thread id in Product Partner.
     * @param {string} [filename] 
     * @param {string} [contentType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public chatUploadFile(file: File, xUserID?: string, xCallerID?: string, xCallerThreadID?: string, filename?: string, contentType?: string, options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).chatUploadFile(file, xUserID, xCallerID, xCallerThreadID, filename, contentType, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DocumentsApi - axios parameter creator
 * @export
 */
export const DocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new Document for the authenticated user\'s organization.
         * @param {DocumentsCreateRequest} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsCreate: async (data: DocumentsCreateRequest, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsCreate', 'data', data)
            const localVarPath = `/documents/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific document.
         * @param {string} id 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsDelete: async (id: string, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentsDelete', 'id', id)
            const localVarPath = `/documents/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve document image
         * @param {string} id 
         * @param {number} [page] A page number within the paginated result set.
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsImageList: async (id: string, page?: number, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentsImageList', 'id', id)
            const localVarPath = `/documents/{id}/image/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all Documents for the authenticated user\'s organization.
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [stakeholders] Comma-separated list of stakeholder user IDs to filter by
         * @param {string} [publishingState] Publishing state to filter by
         * @param {string} [search] Search term to filter Documents by title or body
         * @param {string} [sort] Field to sort by (e.g., \&#39;title\&#39;, \&#39;-created_date\&#39;)
         * @param {number} [limit] Limit the number of Documents returned
         * @param {string} [tags] Comma-separated list of tag names to filter Documents by
         * @param {string} [createdBy] Optional UUID of the user who created the Document to filter Documents by
         * @param {string} [type] Type of document to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsList: async (xUserID?: string, stakeholders?: string, publishingState?: string, search?: string, sort?: string, limit?: number, tags?: string, createdBy?: string, type?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/documents/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (stakeholders !== undefined) {
                localVarQueryParameter['stakeholders'] = stakeholders;
            }

            if (publishingState !== undefined) {
                localVarQueryParameter['publishing_state'] = publishingState;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (createdBy !== undefined) {
                localVarQueryParameter['created_by'] = createdBy;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Partially update a specific document.
         * @param {string} id 
         * @param {Document} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsPartialUpdate: async (id: string, data: Document, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsPartialUpdate', 'data', data)
            const localVarPath = `/documents/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsPickerList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/documents/picker/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a specific document.
         * @param {string} id 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [outputFormat] Response format (json, text, html, docx, pdf)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsRead: async (id: string, xUserID?: string, outputFormat?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentsRead', 'id', id)
            const localVarPath = `/documents/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (outputFormat !== undefined) {
                localVarQueryParameter['output_format'] = outputFormat;
            }


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a specific document.
         * @param {string} id 
         * @param {Document} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsUpdate: async (id: string, data: Document, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsUpdate', 'data', data)
            const localVarPath = `/documents/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentsApi - functional programming interface
 * @export
 */
export const DocumentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new Document for the authenticated user\'s organization.
         * @param {DocumentsCreateRequest} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsCreate(data: DocumentsCreateRequest, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsCreate(data, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specific document.
         * @param {string} id 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsDelete(id: string, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsDelete(id, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve document image
         * @param {string} id 
         * @param {number} [page] A page number within the paginated result set.
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsImageList(id: string, page?: number, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsImageList(id, page, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsImageList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of all Documents for the authenticated user\'s organization.
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [stakeholders] Comma-separated list of stakeholder user IDs to filter by
         * @param {string} [publishingState] Publishing state to filter by
         * @param {string} [search] Search term to filter Documents by title or body
         * @param {string} [sort] Field to sort by (e.g., \&#39;title\&#39;, \&#39;-created_date\&#39;)
         * @param {number} [limit] Limit the number of Documents returned
         * @param {string} [tags] Comma-separated list of tag names to filter Documents by
         * @param {string} [createdBy] Optional UUID of the user who created the Document to filter Documents by
         * @param {string} [type] Type of document to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsList(xUserID?: string, stakeholders?: string, publishingState?: string, search?: string, sort?: string, limit?: number, tags?: string, createdBy?: string, type?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Document>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsList(xUserID, stakeholders, publishingState, search, sort, limit, tags, createdBy, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Partially update a specific document.
         * @param {string} id 
         * @param {Document} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsPartialUpdate(id: string, data: Document, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsPartialUpdate(id, data, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsPickerList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DocumentPicker>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsPickerList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsPickerList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get details of a specific document.
         * @param {string} id 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [outputFormat] Response format (json, text, html, docx, pdf)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsRead(id: string, xUserID?: string, outputFormat?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsRead(id, xUserID, outputFormat, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a specific document.
         * @param {string} id 
         * @param {Document} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsUpdate(id: string, data: Document, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsUpdate(id, data, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DocumentsApi - factory interface
 * @export
 */
export const DocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentsApiFp(configuration)
    return {
        /**
         * Create a new Document for the authenticated user\'s organization.
         * @param {DocumentsCreateRequest} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsCreate(data: DocumentsCreateRequest, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Document> {
            return localVarFp.documentsCreate(data, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific document.
         * @param {string} id 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsDelete(id: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.documentsDelete(id, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve document image
         * @param {string} id 
         * @param {number} [page] A page number within the paginated result set.
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsImageList(id: string, page?: number, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.documentsImageList(id, page, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all Documents for the authenticated user\'s organization.
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [stakeholders] Comma-separated list of stakeholder user IDs to filter by
         * @param {string} [publishingState] Publishing state to filter by
         * @param {string} [search] Search term to filter Documents by title or body
         * @param {string} [sort] Field to sort by (e.g., \&#39;title\&#39;, \&#39;-created_date\&#39;)
         * @param {number} [limit] Limit the number of Documents returned
         * @param {string} [tags] Comma-separated list of tag names to filter Documents by
         * @param {string} [createdBy] Optional UUID of the user who created the Document to filter Documents by
         * @param {string} [type] Type of document to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsList(xUserID?: string, stakeholders?: string, publishingState?: string, search?: string, sort?: string, limit?: number, tags?: string, createdBy?: string, type?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Document>> {
            return localVarFp.documentsList(xUserID, stakeholders, publishingState, search, sort, limit, tags, createdBy, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Partially update a specific document.
         * @param {string} id 
         * @param {Document} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsPartialUpdate(id: string, data: Document, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Document> {
            return localVarFp.documentsPartialUpdate(id, data, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsPickerList(options?: RawAxiosRequestConfig): AxiosPromise<Array<DocumentPicker>> {
            return localVarFp.documentsPickerList(options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a specific document.
         * @param {string} id 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [outputFormat] Response format (json, text, html, docx, pdf)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsRead(id: string, xUserID?: string, outputFormat?: string, options?: RawAxiosRequestConfig): AxiosPromise<Document> {
            return localVarFp.documentsRead(id, xUserID, outputFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a specific document.
         * @param {string} id 
         * @param {Document} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsUpdate(id: string, data: Document, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Document> {
            return localVarFp.documentsUpdate(id, data, xUserID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentsApi - interface
 * @export
 * @interface DocumentsApi
 */
export interface DocumentsApiInterface {
    /**
     * Create a new Document for the authenticated user\'s organization.
     * @param {DocumentsCreateRequest} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    documentsCreate(data: DocumentsCreateRequest, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Document>;

    /**
     * Delete a specific document.
     * @param {string} id 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    documentsDelete(id: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieve document image
     * @param {string} id 
     * @param {number} [page] A page number within the paginated result set.
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    documentsImageList(id: string, page?: number, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Get a list of all Documents for the authenticated user\'s organization.
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {string} [stakeholders] Comma-separated list of stakeholder user IDs to filter by
     * @param {string} [publishingState] Publishing state to filter by
     * @param {string} [search] Search term to filter Documents by title or body
     * @param {string} [sort] Field to sort by (e.g., \&#39;title\&#39;, \&#39;-created_date\&#39;)
     * @param {number} [limit] Limit the number of Documents returned
     * @param {string} [tags] Comma-separated list of tag names to filter Documents by
     * @param {string} [createdBy] Optional UUID of the user who created the Document to filter Documents by
     * @param {string} [type] Type of document to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    documentsList(xUserID?: string, stakeholders?: string, publishingState?: string, search?: string, sort?: string, limit?: number, tags?: string, createdBy?: string, type?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Document>>;

    /**
     * Partially update a specific document.
     * @param {string} id 
     * @param {Document} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    documentsPartialUpdate(id: string, data: Document, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Document>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    documentsPickerList(options?: RawAxiosRequestConfig): AxiosPromise<Array<DocumentPicker>>;

    /**
     * Get details of a specific document.
     * @param {string} id 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {string} [outputFormat] Response format (json, text, html, docx, pdf)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    documentsRead(id: string, xUserID?: string, outputFormat?: string, options?: RawAxiosRequestConfig): AxiosPromise<Document>;

    /**
     * Update a specific document.
     * @param {string} id 
     * @param {Document} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    documentsUpdate(id: string, data: Document, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Document>;

}

/**
 * DocumentsApi - object-oriented interface
 * @export
 * @class DocumentsApi
 * @extends {BaseAPI}
 */
export class DocumentsApi extends BaseAPI implements DocumentsApiInterface {
    /**
     * Create a new Document for the authenticated user\'s organization.
     * @param {DocumentsCreateRequest} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsCreate(data: DocumentsCreateRequest, xUserID?: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsCreate(data, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific document.
     * @param {string} id 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsDelete(id: string, xUserID?: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsDelete(id, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve document image
     * @param {string} id 
     * @param {number} [page] A page number within the paginated result set.
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsImageList(id: string, page?: number, xUserID?: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsImageList(id, page, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all Documents for the authenticated user\'s organization.
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {string} [stakeholders] Comma-separated list of stakeholder user IDs to filter by
     * @param {string} [publishingState] Publishing state to filter by
     * @param {string} [search] Search term to filter Documents by title or body
     * @param {string} [sort] Field to sort by (e.g., \&#39;title\&#39;, \&#39;-created_date\&#39;)
     * @param {number} [limit] Limit the number of Documents returned
     * @param {string} [tags] Comma-separated list of tag names to filter Documents by
     * @param {string} [createdBy] Optional UUID of the user who created the Document to filter Documents by
     * @param {string} [type] Type of document to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsList(xUserID?: string, stakeholders?: string, publishingState?: string, search?: string, sort?: string, limit?: number, tags?: string, createdBy?: string, type?: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsList(xUserID, stakeholders, publishingState, search, sort, limit, tags, createdBy, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Partially update a specific document.
     * @param {string} id 
     * @param {Document} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsPartialUpdate(id: string, data: Document, xUserID?: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsPartialUpdate(id, data, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsPickerList(options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsPickerList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a specific document.
     * @param {string} id 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {string} [outputFormat] Response format (json, text, html, docx, pdf)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsRead(id: string, xUserID?: string, outputFormat?: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsRead(id, xUserID, outputFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a specific document.
     * @param {string} id 
     * @param {Document} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsUpdate(id: string, data: Document, xUserID?: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsUpdate(id, data, xUserID, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GoalsApi - axios parameter creator
 * @export
 */
export const GoalsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new goal.
         * @param {Goal} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        goalsCreate: async (data: Goal, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('goalsCreate', 'data', data)
            const localVarPath = `/goals/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific goal.
         * @param {string} goalId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        goalsDelete: async (goalId: string, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'goalId' is not null or undefined
            assertParamExists('goalsDelete', 'goalId', goalId)
            const localVarPath = `/goals/{goal_id}/`
                .replace(`{${"goal_id"}}`, encodeURIComponent(String(goalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List or Search for Goals
         * @param {string} [search] Search term for goal name, language, or description
         * @param {string} [stakeholderUsers] Comma-separated list of stakeholder IDs
         * @param {string} [status] Filter by status
         * @param {string} [sort] Sort field (prefix with \&#39;-\&#39; for descending order)
         * @param {number} [limit] Limit the number of results
         * @param {string} [tags] Filter by tags, one or more
         * @param {string} [program] Filter by program UUID or name
         * @param {string} [createdBy] Filter to the objects created by this user
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        goalsList: async (search?: string, stakeholderUsers?: string, status?: string, sort?: string, limit?: number, tags?: string, program?: string, createdBy?: string, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/goals/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (stakeholderUsers !== undefined) {
                localVarQueryParameter['stakeholder_users'] = stakeholderUsers;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (program !== undefined) {
                localVarQueryParameter['program'] = program;
            }

            if (createdBy !== undefined) {
                localVarQueryParameter['created_by'] = createdBy;
            }


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Partially update a specific goal.
         * @param {string} goalId 
         * @param {Goal} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        goalsPartialUpdate: async (goalId: string, data: Goal, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'goalId' is not null or undefined
            assertParamExists('goalsPartialUpdate', 'goalId', goalId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('goalsPartialUpdate', 'data', data)
            const localVarPath = `/goals/{goal_id}/`
                .replace(`{${"goal_id"}}`, encodeURIComponent(String(goalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List or Search for Goals in picker, a reduced set of functions and returned values but lighter weight and faster.
         * @param {string} [status] Optional filter to include all goals, pass \&#39;all\&#39; or another status.
         * @param {string} [search] Search term for goal name, language, or description
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        goalsPickerList: async (status?: string, search?: string, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/goals/picker/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a specific goal.
         * @param {string} goalId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        goalsRead: async (goalId: string, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'goalId' is not null or undefined
            assertParamExists('goalsRead', 'goalId', goalId)
            const localVarPath = `/goals/{goal_id}/`
                .replace(`{${"goal_id"}}`, encodeURIComponent(String(goalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a specific goal.
         * @param {string} goalId 
         * @param {Goal} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        goalsUpdate: async (goalId: string, data: Goal, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'goalId' is not null or undefined
            assertParamExists('goalsUpdate', 'goalId', goalId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('goalsUpdate', 'data', data)
            const localVarPath = `/goals/{goal_id}/`
                .replace(`{${"goal_id"}}`, encodeURIComponent(String(goalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GoalsApi - functional programming interface
 * @export
 */
export const GoalsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GoalsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new goal.
         * @param {Goal} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async goalsCreate(data: Goal, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Goal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.goalsCreate(data, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoalsApi.goalsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specific goal.
         * @param {string} goalId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async goalsDelete(goalId: string, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.goalsDelete(goalId, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoalsApi.goalsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List or Search for Goals
         * @param {string} [search] Search term for goal name, language, or description
         * @param {string} [stakeholderUsers] Comma-separated list of stakeholder IDs
         * @param {string} [status] Filter by status
         * @param {string} [sort] Sort field (prefix with \&#39;-\&#39; for descending order)
         * @param {number} [limit] Limit the number of results
         * @param {string} [tags] Filter by tags, one or more
         * @param {string} [program] Filter by program UUID or name
         * @param {string} [createdBy] Filter to the objects created by this user
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async goalsList(search?: string, stakeholderUsers?: string, status?: string, sort?: string, limit?: number, tags?: string, program?: string, createdBy?: string, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Goal>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.goalsList(search, stakeholderUsers, status, sort, limit, tags, program, createdBy, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoalsApi.goalsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Partially update a specific goal.
         * @param {string} goalId 
         * @param {Goal} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async goalsPartialUpdate(goalId: string, data: Goal, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Goal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.goalsPartialUpdate(goalId, data, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoalsApi.goalsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List or Search for Goals in picker, a reduced set of functions and returned values but lighter weight and faster.
         * @param {string} [status] Optional filter to include all goals, pass \&#39;all\&#39; or another status.
         * @param {string} [search] Search term for goal name, language, or description
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async goalsPickerList(status?: string, search?: string, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GoalPicker>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.goalsPickerList(status, search, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoalsApi.goalsPickerList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get details of a specific goal.
         * @param {string} goalId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async goalsRead(goalId: string, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Goal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.goalsRead(goalId, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoalsApi.goalsRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a specific goal.
         * @param {string} goalId 
         * @param {Goal} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async goalsUpdate(goalId: string, data: Goal, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Goal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.goalsUpdate(goalId, data, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoalsApi.goalsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GoalsApi - factory interface
 * @export
 */
export const GoalsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GoalsApiFp(configuration)
    return {
        /**
         * Create a new goal.
         * @param {Goal} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        goalsCreate(data: Goal, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Goal> {
            return localVarFp.goalsCreate(data, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific goal.
         * @param {string} goalId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        goalsDelete(goalId: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.goalsDelete(goalId, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * List or Search for Goals
         * @param {string} [search] Search term for goal name, language, or description
         * @param {string} [stakeholderUsers] Comma-separated list of stakeholder IDs
         * @param {string} [status] Filter by status
         * @param {string} [sort] Sort field (prefix with \&#39;-\&#39; for descending order)
         * @param {number} [limit] Limit the number of results
         * @param {string} [tags] Filter by tags, one or more
         * @param {string} [program] Filter by program UUID or name
         * @param {string} [createdBy] Filter to the objects created by this user
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        goalsList(search?: string, stakeholderUsers?: string, status?: string, sort?: string, limit?: number, tags?: string, program?: string, createdBy?: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Goal>> {
            return localVarFp.goalsList(search, stakeholderUsers, status, sort, limit, tags, program, createdBy, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * Partially update a specific goal.
         * @param {string} goalId 
         * @param {Goal} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        goalsPartialUpdate(goalId: string, data: Goal, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Goal> {
            return localVarFp.goalsPartialUpdate(goalId, data, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * List or Search for Goals in picker, a reduced set of functions and returned values but lighter weight and faster.
         * @param {string} [status] Optional filter to include all goals, pass \&#39;all\&#39; or another status.
         * @param {string} [search] Search term for goal name, language, or description
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        goalsPickerList(status?: string, search?: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GoalPicker>> {
            return localVarFp.goalsPickerList(status, search, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a specific goal.
         * @param {string} goalId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        goalsRead(goalId: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Goal> {
            return localVarFp.goalsRead(goalId, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a specific goal.
         * @param {string} goalId 
         * @param {Goal} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        goalsUpdate(goalId: string, data: Goal, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Goal> {
            return localVarFp.goalsUpdate(goalId, data, xUserID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GoalsApi - interface
 * @export
 * @interface GoalsApi
 */
export interface GoalsApiInterface {
    /**
     * Create a new goal.
     * @param {Goal} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApiInterface
     */
    goalsCreate(data: Goal, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Goal>;

    /**
     * Delete a specific goal.
     * @param {string} goalId 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApiInterface
     */
    goalsDelete(goalId: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * List or Search for Goals
     * @param {string} [search] Search term for goal name, language, or description
     * @param {string} [stakeholderUsers] Comma-separated list of stakeholder IDs
     * @param {string} [status] Filter by status
     * @param {string} [sort] Sort field (prefix with \&#39;-\&#39; for descending order)
     * @param {number} [limit] Limit the number of results
     * @param {string} [tags] Filter by tags, one or more
     * @param {string} [program] Filter by program UUID or name
     * @param {string} [createdBy] Filter to the objects created by this user
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApiInterface
     */
    goalsList(search?: string, stakeholderUsers?: string, status?: string, sort?: string, limit?: number, tags?: string, program?: string, createdBy?: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Goal>>;

    /**
     * Partially update a specific goal.
     * @param {string} goalId 
     * @param {Goal} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApiInterface
     */
    goalsPartialUpdate(goalId: string, data: Goal, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Goal>;

    /**
     * List or Search for Goals in picker, a reduced set of functions and returned values but lighter weight and faster.
     * @param {string} [status] Optional filter to include all goals, pass \&#39;all\&#39; or another status.
     * @param {string} [search] Search term for goal name, language, or description
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApiInterface
     */
    goalsPickerList(status?: string, search?: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GoalPicker>>;

    /**
     * Get details of a specific goal.
     * @param {string} goalId 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApiInterface
     */
    goalsRead(goalId: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Goal>;

    /**
     * Update a specific goal.
     * @param {string} goalId 
     * @param {Goal} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApiInterface
     */
    goalsUpdate(goalId: string, data: Goal, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Goal>;

}

/**
 * GoalsApi - object-oriented interface
 * @export
 * @class GoalsApi
 * @extends {BaseAPI}
 */
export class GoalsApi extends BaseAPI implements GoalsApiInterface {
    /**
     * Create a new goal.
     * @param {Goal} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public goalsCreate(data: Goal, xUserID?: string, options?: RawAxiosRequestConfig) {
        return GoalsApiFp(this.configuration).goalsCreate(data, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific goal.
     * @param {string} goalId 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public goalsDelete(goalId: string, xUserID?: string, options?: RawAxiosRequestConfig) {
        return GoalsApiFp(this.configuration).goalsDelete(goalId, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List or Search for Goals
     * @param {string} [search] Search term for goal name, language, or description
     * @param {string} [stakeholderUsers] Comma-separated list of stakeholder IDs
     * @param {string} [status] Filter by status
     * @param {string} [sort] Sort field (prefix with \&#39;-\&#39; for descending order)
     * @param {number} [limit] Limit the number of results
     * @param {string} [tags] Filter by tags, one or more
     * @param {string} [program] Filter by program UUID or name
     * @param {string} [createdBy] Filter to the objects created by this user
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public goalsList(search?: string, stakeholderUsers?: string, status?: string, sort?: string, limit?: number, tags?: string, program?: string, createdBy?: string, xUserID?: string, options?: RawAxiosRequestConfig) {
        return GoalsApiFp(this.configuration).goalsList(search, stakeholderUsers, status, sort, limit, tags, program, createdBy, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Partially update a specific goal.
     * @param {string} goalId 
     * @param {Goal} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public goalsPartialUpdate(goalId: string, data: Goal, xUserID?: string, options?: RawAxiosRequestConfig) {
        return GoalsApiFp(this.configuration).goalsPartialUpdate(goalId, data, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List or Search for Goals in picker, a reduced set of functions and returned values but lighter weight and faster.
     * @param {string} [status] Optional filter to include all goals, pass \&#39;all\&#39; or another status.
     * @param {string} [search] Search term for goal name, language, or description
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public goalsPickerList(status?: string, search?: string, xUserID?: string, options?: RawAxiosRequestConfig) {
        return GoalsApiFp(this.configuration).goalsPickerList(status, search, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a specific goal.
     * @param {string} goalId 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public goalsRead(goalId: string, xUserID?: string, options?: RawAxiosRequestConfig) {
        return GoalsApiFp(this.configuration).goalsRead(goalId, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a specific goal.
     * @param {string} goalId 
     * @param {Goal} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public goalsUpdate(goalId: string, data: Goal, xUserID?: string, options?: RawAxiosRequestConfig) {
        return GoalsApiFp(this.configuration).goalsUpdate(goalId, data, xUserID, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GoogleDocsApi - axios parameter creator
 * @export
 */
export const GoogleDocsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List Google Docs for the authenticated user\'s organization
         * @param {number} [maxResults] Maximum number of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        googleDocsList: async (maxResults?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/google/docs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the content of a specific Google Doc
         * @param {string} docId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        googleDocsRead: async (docId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'docId' is not null or undefined
            assertParamExists('googleDocsRead', 'docId', docId)
            const localVarPath = `/google/docs/{doc_id}/`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Webhook endpoint for Google Docs notifications
         * @param {string} userId 
         * @param {string} xGoogResourceID Google resource ID
         * @param {string} xGoogChannelID Google channel ID
         * @param {string} xGoogResourceState Resource state (sync, change, update)
         * @param {string} [xGoogChanged] Changed fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        googleDocsWebhook: async (userId: string, xGoogResourceID: string, xGoogChannelID: string, xGoogResourceState: string, xGoogChanged?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('googleDocsWebhook', 'userId', userId)
            // verify required parameter 'xGoogResourceID' is not null or undefined
            assertParamExists('googleDocsWebhook', 'xGoogResourceID', xGoogResourceID)
            // verify required parameter 'xGoogChannelID' is not null or undefined
            assertParamExists('googleDocsWebhook', 'xGoogChannelID', xGoogChannelID)
            // verify required parameter 'xGoogResourceState' is not null or undefined
            assertParamExists('googleDocsWebhook', 'xGoogResourceState', xGoogResourceState)
            const localVarPath = `/google/docs/webhook/{user_id}/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            if (xGoogResourceID != null) {
                localVarHeaderParameter['X-Goog-Resource-ID'] = String(xGoogResourceID);
            }
            if (xGoogChannelID != null) {
                localVarHeaderParameter['X-Goog-Channel-ID'] = String(xGoogChannelID);
            }
            if (xGoogResourceState != null) {
                localVarHeaderParameter['X-Goog-Resource-State'] = String(xGoogResourceState);
            }
            if (xGoogChanged != null) {
                localVarHeaderParameter['X-Goog-Changed'] = String(xGoogChanged);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a Google Doc with the system
         * @param {RegisterGoogleDocRequest} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerGoogleDoc: async (data: RegisterGoogleDocRequest, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('registerGoogleDoc', 'data', data)
            const localVarPath = `/google/docs/register/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set up a watch on a Google Doc to receive notifications about changes
         * @param {string} docId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        watchGoogleDoc: async (docId: string, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'docId' is not null or undefined
            assertParamExists('watchGoogleDoc', 'docId', docId)
            const localVarPath = `/google/docs/{doc_id}/watch/`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GoogleDocsApi - functional programming interface
 * @export
 */
export const GoogleDocsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GoogleDocsApiAxiosParamCreator(configuration)
    return {
        /**
         * List Google Docs for the authenticated user\'s organization
         * @param {number} [maxResults] Maximum number of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async googleDocsList(maxResults?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.googleDocsList(maxResults, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleDocsApi.googleDocsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the content of a specific Google Doc
         * @param {string} docId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async googleDocsRead(docId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.googleDocsRead(docId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleDocsApi.googleDocsRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Webhook endpoint for Google Docs notifications
         * @param {string} userId 
         * @param {string} xGoogResourceID Google resource ID
         * @param {string} xGoogChannelID Google channel ID
         * @param {string} xGoogResourceState Resource state (sync, change, update)
         * @param {string} [xGoogChanged] Changed fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async googleDocsWebhook(userId: string, xGoogResourceID: string, xGoogChannelID: string, xGoogResourceState: string, xGoogChanged?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoogleDocsWebhook200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.googleDocsWebhook(userId, xGoogResourceID, xGoogChannelID, xGoogResourceState, xGoogChanged, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleDocsApi.googleDocsWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Register a Google Doc with the system
         * @param {RegisterGoogleDocRequest} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerGoogleDoc(data: RegisterGoogleDocRequest, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterGoogleDoc200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerGoogleDoc(data, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleDocsApi.registerGoogleDoc']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set up a watch on a Google Doc to receive notifications about changes
         * @param {string} docId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async watchGoogleDoc(docId: string, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchGoogleDoc200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.watchGoogleDoc(docId, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleDocsApi.watchGoogleDoc']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GoogleDocsApi - factory interface
 * @export
 */
export const GoogleDocsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GoogleDocsApiFp(configuration)
    return {
        /**
         * List Google Docs for the authenticated user\'s organization
         * @param {number} [maxResults] Maximum number of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        googleDocsList(maxResults?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.googleDocsList(maxResults, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the content of a specific Google Doc
         * @param {string} docId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        googleDocsRead(docId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.googleDocsRead(docId, options).then((request) => request(axios, basePath));
        },
        /**
         * Webhook endpoint for Google Docs notifications
         * @param {string} userId 
         * @param {string} xGoogResourceID Google resource ID
         * @param {string} xGoogChannelID Google channel ID
         * @param {string} xGoogResourceState Resource state (sync, change, update)
         * @param {string} [xGoogChanged] Changed fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        googleDocsWebhook(userId: string, xGoogResourceID: string, xGoogChannelID: string, xGoogResourceState: string, xGoogChanged?: string, options?: RawAxiosRequestConfig): AxiosPromise<GoogleDocsWebhook200Response> {
            return localVarFp.googleDocsWebhook(userId, xGoogResourceID, xGoogChannelID, xGoogResourceState, xGoogChanged, options).then((request) => request(axios, basePath));
        },
        /**
         * Register a Google Doc with the system
         * @param {RegisterGoogleDocRequest} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerGoogleDoc(data: RegisterGoogleDocRequest, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<RegisterGoogleDoc200Response> {
            return localVarFp.registerGoogleDoc(data, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * Set up a watch on a Google Doc to receive notifications about changes
         * @param {string} docId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        watchGoogleDoc(docId: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<WatchGoogleDoc200Response> {
            return localVarFp.watchGoogleDoc(docId, xUserID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GoogleDocsApi - interface
 * @export
 * @interface GoogleDocsApi
 */
export interface GoogleDocsApiInterface {
    /**
     * List Google Docs for the authenticated user\'s organization
     * @param {number} [maxResults] Maximum number of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleDocsApiInterface
     */
    googleDocsList(maxResults?: number, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Get the content of a specific Google Doc
     * @param {string} docId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleDocsApiInterface
     */
    googleDocsRead(docId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Webhook endpoint for Google Docs notifications
     * @param {string} userId 
     * @param {string} xGoogResourceID Google resource ID
     * @param {string} xGoogChannelID Google channel ID
     * @param {string} xGoogResourceState Resource state (sync, change, update)
     * @param {string} [xGoogChanged] Changed fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleDocsApiInterface
     */
    googleDocsWebhook(userId: string, xGoogResourceID: string, xGoogChannelID: string, xGoogResourceState: string, xGoogChanged?: string, options?: RawAxiosRequestConfig): AxiosPromise<GoogleDocsWebhook200Response>;

    /**
     * Register a Google Doc with the system
     * @param {RegisterGoogleDocRequest} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleDocsApiInterface
     */
    registerGoogleDoc(data: RegisterGoogleDocRequest, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<RegisterGoogleDoc200Response>;

    /**
     * Set up a watch on a Google Doc to receive notifications about changes
     * @param {string} docId 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleDocsApiInterface
     */
    watchGoogleDoc(docId: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<WatchGoogleDoc200Response>;

}

/**
 * GoogleDocsApi - object-oriented interface
 * @export
 * @class GoogleDocsApi
 * @extends {BaseAPI}
 */
export class GoogleDocsApi extends BaseAPI implements GoogleDocsApiInterface {
    /**
     * List Google Docs for the authenticated user\'s organization
     * @param {number} [maxResults] Maximum number of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleDocsApi
     */
    public googleDocsList(maxResults?: number, options?: RawAxiosRequestConfig) {
        return GoogleDocsApiFp(this.configuration).googleDocsList(maxResults, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the content of a specific Google Doc
     * @param {string} docId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleDocsApi
     */
    public googleDocsRead(docId: string, options?: RawAxiosRequestConfig) {
        return GoogleDocsApiFp(this.configuration).googleDocsRead(docId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Webhook endpoint for Google Docs notifications
     * @param {string} userId 
     * @param {string} xGoogResourceID Google resource ID
     * @param {string} xGoogChannelID Google channel ID
     * @param {string} xGoogResourceState Resource state (sync, change, update)
     * @param {string} [xGoogChanged] Changed fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleDocsApi
     */
    public googleDocsWebhook(userId: string, xGoogResourceID: string, xGoogChannelID: string, xGoogResourceState: string, xGoogChanged?: string, options?: RawAxiosRequestConfig) {
        return GoogleDocsApiFp(this.configuration).googleDocsWebhook(userId, xGoogResourceID, xGoogChannelID, xGoogResourceState, xGoogChanged, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register a Google Doc with the system
     * @param {RegisterGoogleDocRequest} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleDocsApi
     */
    public registerGoogleDoc(data: RegisterGoogleDocRequest, xUserID?: string, options?: RawAxiosRequestConfig) {
        return GoogleDocsApiFp(this.configuration).registerGoogleDoc(data, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set up a watch on a Google Doc to receive notifications about changes
     * @param {string} docId 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleDocsApi
     */
    public watchGoogleDoc(docId: string, xUserID?: string, options?: RawAxiosRequestConfig) {
        return GoogleDocsApiFp(this.configuration).watchGoogleDoc(docId, xUserID, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GoogleOAuthApi - axios parameter creator
 * @export
 */
export const GoogleOAuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Handle the OAuth callback from Google
         * @param {string} [code] Authorization code from Google
         * @param {string} [state] State token for verification
         * @param {string} [error] Error message if OAuth failed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthGoogleCallback: async (code?: string, state?: string, error?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth/google/callback/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (error !== undefined) {
                localVarQueryParameter['error'] = error;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start the Google OAuth flow by redirecting to Google
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthGoogleStart: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth/google/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Toggle Google sync enabled status for the organization
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleGoogleSync: async (xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth/google/toggle-sync`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GoogleOAuthApi - functional programming interface
 * @export
 */
export const GoogleOAuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GoogleOAuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Handle the OAuth callback from Google
         * @param {string} [code] Authorization code from Google
         * @param {string} [state] State token for verification
         * @param {string} [error] Error message if OAuth failed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthGoogleCallback(code?: string, state?: string, error?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthGoogleCallback(code, state, error, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleOAuthApi.oauthGoogleCallback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start the Google OAuth flow by redirecting to Google
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthGoogleStart(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthGoogleStart(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleOAuthApi.oauthGoogleStart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Toggle Google sync enabled status for the organization
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toggleGoogleSync(xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toggleGoogleSync(xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleOAuthApi.toggleGoogleSync']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GoogleOAuthApi - factory interface
 * @export
 */
export const GoogleOAuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GoogleOAuthApiFp(configuration)
    return {
        /**
         * Handle the OAuth callback from Google
         * @param {string} [code] Authorization code from Google
         * @param {string} [state] State token for verification
         * @param {string} [error] Error message if OAuth failed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthGoogleCallback(code?: string, state?: string, error?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.oauthGoogleCallback(code, state, error, options).then((request) => request(axios, basePath));
        },
        /**
         * Start the Google OAuth flow by redirecting to Google
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthGoogleStart(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.oauthGoogleStart(options).then((request) => request(axios, basePath));
        },
        /**
         * Toggle Google sync enabled status for the organization
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleGoogleSync(xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.toggleGoogleSync(xUserID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GoogleOAuthApi - interface
 * @export
 * @interface GoogleOAuthApi
 */
export interface GoogleOAuthApiInterface {
    /**
     * Handle the OAuth callback from Google
     * @param {string} [code] Authorization code from Google
     * @param {string} [state] State token for verification
     * @param {string} [error] Error message if OAuth failed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleOAuthApiInterface
     */
    oauthGoogleCallback(code?: string, state?: string, error?: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Start the Google OAuth flow by redirecting to Google
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleOAuthApiInterface
     */
    oauthGoogleStart(options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Toggle Google sync enabled status for the organization
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleOAuthApiInterface
     */
    toggleGoogleSync(xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

}

/**
 * GoogleOAuthApi - object-oriented interface
 * @export
 * @class GoogleOAuthApi
 * @extends {BaseAPI}
 */
export class GoogleOAuthApi extends BaseAPI implements GoogleOAuthApiInterface {
    /**
     * Handle the OAuth callback from Google
     * @param {string} [code] Authorization code from Google
     * @param {string} [state] State token for verification
     * @param {string} [error] Error message if OAuth failed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleOAuthApi
     */
    public oauthGoogleCallback(code?: string, state?: string, error?: string, options?: RawAxiosRequestConfig) {
        return GoogleOAuthApiFp(this.configuration).oauthGoogleCallback(code, state, error, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start the Google OAuth flow by redirecting to Google
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleOAuthApi
     */
    public oauthGoogleStart(options?: RawAxiosRequestConfig) {
        return GoogleOAuthApiFp(this.configuration).oauthGoogleStart(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Toggle Google sync enabled status for the organization
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleOAuthApi
     */
    public toggleGoogleSync(xUserID?: string, options?: RawAxiosRequestConfig) {
        return GoogleOAuthApiFp(this.configuration).toggleGoogleSync(xUserID, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JiraApi - axios parameter creator
 * @export
 */
export const JiraApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Handle the OAuth callback from Atlassian
         * @param {string} [code] Authorization code from Atlassian
         * @param {string} [state] State token for verification
         * @param {string} [error] Error message if OAuth failed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jiraOauthCallback: async (code?: string, state?: string, error?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/jira/oauth/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (error !== undefined) {
                localVarQueryParameter['error'] = error;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start the Jira OAuth flow by redirecting to Atlassian
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jiraOauthStart: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/jira/oauth/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Toggle Jira sync enabled status for the organization
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jiraOauthToggleSync: async (xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/jira/oauth/toggle-sync`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} objectId 
         * @param {JiraSyncDocumentsCreateRequest} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jiraSyncDocumentsCreate: async (objectId: string, data: JiraSyncDocumentsCreateRequest, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('jiraSyncDocumentsCreate', 'objectId', objectId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('jiraSyncDocumentsCreate', 'data', data)
            const localVarPath = `/jira/sync/documents/{object_id}/`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} objectId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jiraSyncDocumentsRead: async (objectId: string, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('jiraSyncDocumentsRead', 'objectId', objectId)
            const localVarPath = `/jira/sync/documents/{object_id}/`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} objectId 
         * @param {JiraSyncDocumentsCreateRequest} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jiraSyncProgramsCreate: async (objectId: string, data: JiraSyncDocumentsCreateRequest, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('jiraSyncProgramsCreate', 'objectId', objectId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('jiraSyncProgramsCreate', 'data', data)
            const localVarPath = `/jira/sync/programs/{object_id}/`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} objectId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jiraSyncProgramsRead: async (objectId: string, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('jiraSyncProgramsRead', 'objectId', objectId)
            const localVarPath = `/jira/sync/programs/{object_id}/`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jiraSyncStatusList: async (xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/jira/sync/status/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} objectId 
         * @param {JiraSyncDocumentsCreateRequest} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jiraSyncUserstoriesCreate: async (objectId: string, data: JiraSyncDocumentsCreateRequest, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('jiraSyncUserstoriesCreate', 'objectId', objectId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('jiraSyncUserstoriesCreate', 'data', data)
            const localVarPath = `/jira/sync/userstories/{object_id}/`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} objectId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jiraSyncUserstoriesRead: async (objectId: string, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('jiraSyncUserstoriesRead', 'objectId', objectId)
            const localVarPath = `/jira/sync/userstories/{object_id}/`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Publish or update a document as a Jira epic
         * @param {string} docId 
         * @param {PublishDocAsEpicRequest} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishDocAsEpic: async (docId: string, data: PublishDocAsEpicRequest, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'docId' is not null or undefined
            assertParamExists('publishDocAsEpic', 'docId', docId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('publishDocAsEpic', 'data', data)
            const localVarPath = `/jira/documents/{doc_id}/publish`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JiraApi - functional programming interface
 * @export
 */
export const JiraApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JiraApiAxiosParamCreator(configuration)
    return {
        /**
         * Handle the OAuth callback from Atlassian
         * @param {string} [code] Authorization code from Atlassian
         * @param {string} [state] State token for verification
         * @param {string} [error] Error message if OAuth failed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jiraOauthCallback(code?: string, state?: string, error?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jiraOauthCallback(code, state, error, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JiraApi.jiraOauthCallback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start the Jira OAuth flow by redirecting to Atlassian
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jiraOauthStart(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jiraOauthStart(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JiraApi.jiraOauthStart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Toggle Jira sync enabled status for the organization
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jiraOauthToggleSync(xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jiraOauthToggleSync(xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JiraApi.jiraOauthToggleSync']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} objectId 
         * @param {JiraSyncDocumentsCreateRequest} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jiraSyncDocumentsCreate(objectId: string, data: JiraSyncDocumentsCreateRequest, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jiraSyncDocumentsCreate(objectId, data, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JiraApi.jiraSyncDocumentsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} objectId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jiraSyncDocumentsRead(objectId: string, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jiraSyncDocumentsRead(objectId, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JiraApi.jiraSyncDocumentsRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} objectId 
         * @param {JiraSyncDocumentsCreateRequest} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jiraSyncProgramsCreate(objectId: string, data: JiraSyncDocumentsCreateRequest, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jiraSyncProgramsCreate(objectId, data, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JiraApi.jiraSyncProgramsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} objectId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jiraSyncProgramsRead(objectId: string, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jiraSyncProgramsRead(objectId, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JiraApi.jiraSyncProgramsRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jiraSyncStatusList(xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jiraSyncStatusList(xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JiraApi.jiraSyncStatusList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} objectId 
         * @param {JiraSyncDocumentsCreateRequest} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jiraSyncUserstoriesCreate(objectId: string, data: JiraSyncDocumentsCreateRequest, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jiraSyncUserstoriesCreate(objectId, data, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JiraApi.jiraSyncUserstoriesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} objectId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jiraSyncUserstoriesRead(objectId: string, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jiraSyncUserstoriesRead(objectId, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JiraApi.jiraSyncUserstoriesRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Publish or update a document as a Jira epic
         * @param {string} docId 
         * @param {PublishDocAsEpicRequest} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publishDocAsEpic(docId: string, data: PublishDocAsEpicRequest, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publishDocAsEpic(docId, data, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JiraApi.publishDocAsEpic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * JiraApi - factory interface
 * @export
 */
export const JiraApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JiraApiFp(configuration)
    return {
        /**
         * Handle the OAuth callback from Atlassian
         * @param {string} [code] Authorization code from Atlassian
         * @param {string} [state] State token for verification
         * @param {string} [error] Error message if OAuth failed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jiraOauthCallback(code?: string, state?: string, error?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.jiraOauthCallback(code, state, error, options).then((request) => request(axios, basePath));
        },
        /**
         * Start the Jira OAuth flow by redirecting to Atlassian
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jiraOauthStart(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.jiraOauthStart(options).then((request) => request(axios, basePath));
        },
        /**
         * Toggle Jira sync enabled status for the organization
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jiraOauthToggleSync(xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.jiraOauthToggleSync(xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} objectId 
         * @param {JiraSyncDocumentsCreateRequest} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jiraSyncDocumentsCreate(objectId: string, data: JiraSyncDocumentsCreateRequest, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.jiraSyncDocumentsCreate(objectId, data, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} objectId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jiraSyncDocumentsRead(objectId: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.jiraSyncDocumentsRead(objectId, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} objectId 
         * @param {JiraSyncDocumentsCreateRequest} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jiraSyncProgramsCreate(objectId: string, data: JiraSyncDocumentsCreateRequest, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.jiraSyncProgramsCreate(objectId, data, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} objectId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jiraSyncProgramsRead(objectId: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.jiraSyncProgramsRead(objectId, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jiraSyncStatusList(xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.jiraSyncStatusList(xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} objectId 
         * @param {JiraSyncDocumentsCreateRequest} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jiraSyncUserstoriesCreate(objectId: string, data: JiraSyncDocumentsCreateRequest, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.jiraSyncUserstoriesCreate(objectId, data, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} objectId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jiraSyncUserstoriesRead(objectId: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.jiraSyncUserstoriesRead(objectId, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * Publish or update a document as a Jira epic
         * @param {string} docId 
         * @param {PublishDocAsEpicRequest} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishDocAsEpic(docId: string, data: PublishDocAsEpicRequest, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.publishDocAsEpic(docId, data, xUserID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JiraApi - interface
 * @export
 * @interface JiraApi
 */
export interface JiraApiInterface {
    /**
     * Handle the OAuth callback from Atlassian
     * @param {string} [code] Authorization code from Atlassian
     * @param {string} [state] State token for verification
     * @param {string} [error] Error message if OAuth failed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApiInterface
     */
    jiraOauthCallback(code?: string, state?: string, error?: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Start the Jira OAuth flow by redirecting to Atlassian
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApiInterface
     */
    jiraOauthStart(options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Toggle Jira sync enabled status for the organization
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApiInterface
     */
    jiraOauthToggleSync(xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} objectId 
     * @param {JiraSyncDocumentsCreateRequest} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApiInterface
     */
    jiraSyncDocumentsCreate(objectId: string, data: JiraSyncDocumentsCreateRequest, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} objectId 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApiInterface
     */
    jiraSyncDocumentsRead(objectId: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} objectId 
     * @param {JiraSyncDocumentsCreateRequest} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApiInterface
     */
    jiraSyncProgramsCreate(objectId: string, data: JiraSyncDocumentsCreateRequest, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} objectId 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApiInterface
     */
    jiraSyncProgramsRead(objectId: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApiInterface
     */
    jiraSyncStatusList(xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} objectId 
     * @param {JiraSyncDocumentsCreateRequest} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApiInterface
     */
    jiraSyncUserstoriesCreate(objectId: string, data: JiraSyncDocumentsCreateRequest, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} objectId 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApiInterface
     */
    jiraSyncUserstoriesRead(objectId: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Publish or update a document as a Jira epic
     * @param {string} docId 
     * @param {PublishDocAsEpicRequest} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApiInterface
     */
    publishDocAsEpic(docId: string, data: PublishDocAsEpicRequest, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

}

/**
 * JiraApi - object-oriented interface
 * @export
 * @class JiraApi
 * @extends {BaseAPI}
 */
export class JiraApi extends BaseAPI implements JiraApiInterface {
    /**
     * Handle the OAuth callback from Atlassian
     * @param {string} [code] Authorization code from Atlassian
     * @param {string} [state] State token for verification
     * @param {string} [error] Error message if OAuth failed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApi
     */
    public jiraOauthCallback(code?: string, state?: string, error?: string, options?: RawAxiosRequestConfig) {
        return JiraApiFp(this.configuration).jiraOauthCallback(code, state, error, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start the Jira OAuth flow by redirecting to Atlassian
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApi
     */
    public jiraOauthStart(options?: RawAxiosRequestConfig) {
        return JiraApiFp(this.configuration).jiraOauthStart(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Toggle Jira sync enabled status for the organization
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApi
     */
    public jiraOauthToggleSync(xUserID?: string, options?: RawAxiosRequestConfig) {
        return JiraApiFp(this.configuration).jiraOauthToggleSync(xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} objectId 
     * @param {JiraSyncDocumentsCreateRequest} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApi
     */
    public jiraSyncDocumentsCreate(objectId: string, data: JiraSyncDocumentsCreateRequest, xUserID?: string, options?: RawAxiosRequestConfig) {
        return JiraApiFp(this.configuration).jiraSyncDocumentsCreate(objectId, data, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} objectId 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApi
     */
    public jiraSyncDocumentsRead(objectId: string, xUserID?: string, options?: RawAxiosRequestConfig) {
        return JiraApiFp(this.configuration).jiraSyncDocumentsRead(objectId, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} objectId 
     * @param {JiraSyncDocumentsCreateRequest} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApi
     */
    public jiraSyncProgramsCreate(objectId: string, data: JiraSyncDocumentsCreateRequest, xUserID?: string, options?: RawAxiosRequestConfig) {
        return JiraApiFp(this.configuration).jiraSyncProgramsCreate(objectId, data, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} objectId 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApi
     */
    public jiraSyncProgramsRead(objectId: string, xUserID?: string, options?: RawAxiosRequestConfig) {
        return JiraApiFp(this.configuration).jiraSyncProgramsRead(objectId, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApi
     */
    public jiraSyncStatusList(xUserID?: string, options?: RawAxiosRequestConfig) {
        return JiraApiFp(this.configuration).jiraSyncStatusList(xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} objectId 
     * @param {JiraSyncDocumentsCreateRequest} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApi
     */
    public jiraSyncUserstoriesCreate(objectId: string, data: JiraSyncDocumentsCreateRequest, xUserID?: string, options?: RawAxiosRequestConfig) {
        return JiraApiFp(this.configuration).jiraSyncUserstoriesCreate(objectId, data, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} objectId 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApi
     */
    public jiraSyncUserstoriesRead(objectId: string, xUserID?: string, options?: RawAxiosRequestConfig) {
        return JiraApiFp(this.configuration).jiraSyncUserstoriesRead(objectId, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Publish or update a document as a Jira epic
     * @param {string} docId 
     * @param {PublishDocAsEpicRequest} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApi
     */
    public publishDocAsEpic(docId: string, data: PublishDocAsEpicRequest, xUserID?: string, options?: RawAxiosRequestConfig) {
        return JiraApiFp(this.configuration).publishDocAsEpic(docId, data, xUserID, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProgramsApi - axios parameter creator
 * @export
 */
export const ProgramsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new program for the authenticated user.
         * @param {Program} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsCreate: async (data: Program, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('programsCreate', 'data', data)
            const localVarPath = `/programs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific program.
         * @param {string} programId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsDelete: async (programId: string, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('programsDelete', 'programId', programId)
            const localVarPath = `/programs/{program_id}/`
                .replace(`{${"program_id"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all programs for the authenticated user.
         * @param {number} [page] A page number within the paginated result set.
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [search] Search in name and description
         * @param {string} [tags] Filter by tags (comma-separated)
         * @param {string} [sort] Sort by field (prefix with \&#39;-\&#39; for descending)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsList: async (page?: number, xUserID?: string, search?: string, tags?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/programs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Partially update a specific program.
         * @param {string} programId 
         * @param {Program} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsPartialUpdate: async (programId: string, data: Program, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('programsPartialUpdate', 'programId', programId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('programsPartialUpdate', 'data', data)
            const localVarPath = `/programs/{program_id}/`
                .replace(`{${"program_id"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsPickerList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/programs/picker/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a specific program.
         * @param {string} programId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsRead: async (programId: string, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('programsRead', 'programId', programId)
            const localVarPath = `/programs/{program_id}/`
                .replace(`{${"program_id"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a specific program.
         * @param {string} programId 
         * @param {Program} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsUpdate: async (programId: string, data: Program, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('programsUpdate', 'programId', programId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('programsUpdate', 'data', data)
            const localVarPath = `/programs/{program_id}/`
                .replace(`{${"program_id"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProgramsApi - functional programming interface
 * @export
 */
export const ProgramsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProgramsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new program for the authenticated user.
         * @param {Program} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async programsCreate(data: Program, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Program>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.programsCreate(data, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProgramsApi.programsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specific program.
         * @param {string} programId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async programsDelete(programId: string, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.programsDelete(programId, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProgramsApi.programsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of all programs for the authenticated user.
         * @param {number} [page] A page number within the paginated result set.
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [search] Search in name and description
         * @param {string} [tags] Filter by tags (comma-separated)
         * @param {string} [sort] Sort by field (prefix with \&#39;-\&#39; for descending)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async programsList(page?: number, xUserID?: string, search?: string, tags?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Program>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.programsList(page, xUserID, search, tags, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProgramsApi.programsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Partially update a specific program.
         * @param {string} programId 
         * @param {Program} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async programsPartialUpdate(programId: string, data: Program, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Program>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.programsPartialUpdate(programId, data, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProgramsApi.programsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async programsPickerList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProgramPicker>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.programsPickerList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProgramsApi.programsPickerList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get details of a specific program.
         * @param {string} programId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async programsRead(programId: string, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Program>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.programsRead(programId, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProgramsApi.programsRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a specific program.
         * @param {string} programId 
         * @param {Program} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async programsUpdate(programId: string, data: Program, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Program>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.programsUpdate(programId, data, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProgramsApi.programsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProgramsApi - factory interface
 * @export
 */
export const ProgramsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProgramsApiFp(configuration)
    return {
        /**
         * Create a new program for the authenticated user.
         * @param {Program} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsCreate(data: Program, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Program> {
            return localVarFp.programsCreate(data, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific program.
         * @param {string} programId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsDelete(programId: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.programsDelete(programId, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all programs for the authenticated user.
         * @param {number} [page] A page number within the paginated result set.
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [search] Search in name and description
         * @param {string} [tags] Filter by tags (comma-separated)
         * @param {string} [sort] Sort by field (prefix with \&#39;-\&#39; for descending)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsList(page?: number, xUserID?: string, search?: string, tags?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Program>> {
            return localVarFp.programsList(page, xUserID, search, tags, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Partially update a specific program.
         * @param {string} programId 
         * @param {Program} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsPartialUpdate(programId: string, data: Program, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Program> {
            return localVarFp.programsPartialUpdate(programId, data, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsPickerList(options?: RawAxiosRequestConfig): AxiosPromise<Array<ProgramPicker>> {
            return localVarFp.programsPickerList(options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a specific program.
         * @param {string} programId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsRead(programId: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Program> {
            return localVarFp.programsRead(programId, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a specific program.
         * @param {string} programId 
         * @param {Program} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsUpdate(programId: string, data: Program, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Program> {
            return localVarFp.programsUpdate(programId, data, xUserID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProgramsApi - interface
 * @export
 * @interface ProgramsApi
 */
export interface ProgramsApiInterface {
    /**
     * Create a new program for the authenticated user.
     * @param {Program} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramsApiInterface
     */
    programsCreate(data: Program, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Program>;

    /**
     * Delete a specific program.
     * @param {string} programId 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramsApiInterface
     */
    programsDelete(programId: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Get a list of all programs for the authenticated user.
     * @param {number} [page] A page number within the paginated result set.
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {string} [search] Search in name and description
     * @param {string} [tags] Filter by tags (comma-separated)
     * @param {string} [sort] Sort by field (prefix with \&#39;-\&#39; for descending)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramsApiInterface
     */
    programsList(page?: number, xUserID?: string, search?: string, tags?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Program>>;

    /**
     * Partially update a specific program.
     * @param {string} programId 
     * @param {Program} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramsApiInterface
     */
    programsPartialUpdate(programId: string, data: Program, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Program>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramsApiInterface
     */
    programsPickerList(options?: RawAxiosRequestConfig): AxiosPromise<Array<ProgramPicker>>;

    /**
     * Get details of a specific program.
     * @param {string} programId 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramsApiInterface
     */
    programsRead(programId: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Program>;

    /**
     * Update a specific program.
     * @param {string} programId 
     * @param {Program} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramsApiInterface
     */
    programsUpdate(programId: string, data: Program, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Program>;

}

/**
 * ProgramsApi - object-oriented interface
 * @export
 * @class ProgramsApi
 * @extends {BaseAPI}
 */
export class ProgramsApi extends BaseAPI implements ProgramsApiInterface {
    /**
     * Create a new program for the authenticated user.
     * @param {Program} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramsApi
     */
    public programsCreate(data: Program, xUserID?: string, options?: RawAxiosRequestConfig) {
        return ProgramsApiFp(this.configuration).programsCreate(data, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific program.
     * @param {string} programId 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramsApi
     */
    public programsDelete(programId: string, xUserID?: string, options?: RawAxiosRequestConfig) {
        return ProgramsApiFp(this.configuration).programsDelete(programId, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all programs for the authenticated user.
     * @param {number} [page] A page number within the paginated result set.
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {string} [search] Search in name and description
     * @param {string} [tags] Filter by tags (comma-separated)
     * @param {string} [sort] Sort by field (prefix with \&#39;-\&#39; for descending)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramsApi
     */
    public programsList(page?: number, xUserID?: string, search?: string, tags?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return ProgramsApiFp(this.configuration).programsList(page, xUserID, search, tags, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Partially update a specific program.
     * @param {string} programId 
     * @param {Program} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramsApi
     */
    public programsPartialUpdate(programId: string, data: Program, xUserID?: string, options?: RawAxiosRequestConfig) {
        return ProgramsApiFp(this.configuration).programsPartialUpdate(programId, data, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramsApi
     */
    public programsPickerList(options?: RawAxiosRequestConfig) {
        return ProgramsApiFp(this.configuration).programsPickerList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a specific program.
     * @param {string} programId 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramsApi
     */
    public programsRead(programId: string, xUserID?: string, options?: RawAxiosRequestConfig) {
        return ProgramsApiFp(this.configuration).programsRead(programId, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a specific program.
     * @param {string} programId 
     * @param {Program} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramsApi
     */
    public programsUpdate(programId: string, data: Program, xUserID?: string, options?: RawAxiosRequestConfig) {
        return ProgramsApiFp(this.configuration).programsUpdate(programId, data, xUserID, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new status for the authenticated user.
         * @param {StatusCreateRequest} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusCreate: async (data: StatusCreateRequest, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('statusCreate', 'data', data)
            const localVarPath = `/status/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific status.
         * @param {string} statusId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusDelete: async (statusId: string, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'statusId' is not null or undefined
            assertParamExists('statusDelete', 'statusId', statusId)
            const localVarPath = `/status/{status_id}/`
                .replace(`{${"status_id"}}`, encodeURIComponent(String(statusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all statuses for the authenticated user.
         * @param {number} [page] A page number within the paginated result set.
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [status] Filter by a status value
         * @param {string} [search] Search by keyword against status note or path to green
         * @param {string} [sort] Sort by field (prefix with \&#39;-\&#39; for descending)
         * @param {string} [limit] Sort by field (prefix with \&#39;-\&#39; for descending)
         * @param {string} [goalIds] Filter on goals, using the UUID of the goal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusList: async (page?: number, xUserID?: string, status?: string, search?: string, sort?: string, limit?: string, goalIds?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/status/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (goalIds !== undefined) {
                localVarQueryParameter['goal_ids'] = goalIds;
            }


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Partially update a specific status.
         * @param {string} statusId 
         * @param {Status} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusPartialUpdate: async (statusId: string, data: Status, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'statusId' is not null or undefined
            assertParamExists('statusPartialUpdate', 'statusId', statusId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('statusPartialUpdate', 'data', data)
            const localVarPath = `/status/{status_id}/`
                .replace(`{${"status_id"}}`, encodeURIComponent(String(statusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a specific status.
         * @param {string} statusId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusRead: async (statusId: string, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'statusId' is not null or undefined
            assertParamExists('statusRead', 'statusId', statusId)
            const localVarPath = `/status/{status_id}/`
                .replace(`{${"status_id"}}`, encodeURIComponent(String(statusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a specific status.
         * @param {string} statusId 
         * @param {Status} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusUpdate: async (statusId: string, data: Status, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'statusId' is not null or undefined
            assertParamExists('statusUpdate', 'statusId', statusId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('statusUpdate', 'data', data)
            const localVarPath = `/status/{status_id}/`
                .replace(`{${"status_id"}}`, encodeURIComponent(String(statusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatusApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new status for the authenticated user.
         * @param {StatusCreateRequest} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusCreate(data: StatusCreateRequest, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusCreate(data, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusApi.statusCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specific status.
         * @param {string} statusId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusDelete(statusId: string, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusDelete(statusId, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusApi.statusDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of all statuses for the authenticated user.
         * @param {number} [page] A page number within the paginated result set.
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [status] Filter by a status value
         * @param {string} [search] Search by keyword against status note or path to green
         * @param {string} [sort] Sort by field (prefix with \&#39;-\&#39; for descending)
         * @param {string} [limit] Sort by field (prefix with \&#39;-\&#39; for descending)
         * @param {string} [goalIds] Filter on goals, using the UUID of the goal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusList(page?: number, xUserID?: string, status?: string, search?: string, sort?: string, limit?: string, goalIds?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Status>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusList(page, xUserID, status, search, sort, limit, goalIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusApi.statusList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Partially update a specific status.
         * @param {string} statusId 
         * @param {Status} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusPartialUpdate(statusId: string, data: Status, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusPartialUpdate(statusId, data, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusApi.statusPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get details of a specific status.
         * @param {string} statusId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusRead(statusId: string, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusRead(statusId, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusApi.statusRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a specific status.
         * @param {string} statusId 
         * @param {Status} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusUpdate(statusId: string, data: Status, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusUpdate(statusId, data, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusApi.statusUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatusApiFp(configuration)
    return {
        /**
         * Create a new status for the authenticated user.
         * @param {StatusCreateRequest} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusCreate(data: StatusCreateRequest, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.statusCreate(data, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific status.
         * @param {string} statusId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusDelete(statusId: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.statusDelete(statusId, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all statuses for the authenticated user.
         * @param {number} [page] A page number within the paginated result set.
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [status] Filter by a status value
         * @param {string} [search] Search by keyword against status note or path to green
         * @param {string} [sort] Sort by field (prefix with \&#39;-\&#39; for descending)
         * @param {string} [limit] Sort by field (prefix with \&#39;-\&#39; for descending)
         * @param {string} [goalIds] Filter on goals, using the UUID of the goal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusList(page?: number, xUserID?: string, status?: string, search?: string, sort?: string, limit?: string, goalIds?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Status>> {
            return localVarFp.statusList(page, xUserID, status, search, sort, limit, goalIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Partially update a specific status.
         * @param {string} statusId 
         * @param {Status} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusPartialUpdate(statusId: string, data: Status, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.statusPartialUpdate(statusId, data, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a specific status.
         * @param {string} statusId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusRead(statusId: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.statusRead(statusId, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a specific status.
         * @param {string} statusId 
         * @param {Status} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusUpdate(statusId: string, data: Status, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.statusUpdate(statusId, data, xUserID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatusApi - interface
 * @export
 * @interface StatusApi
 */
export interface StatusApiInterface {
    /**
     * Create a new status for the authenticated user.
     * @param {StatusCreateRequest} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApiInterface
     */
    statusCreate(data: StatusCreateRequest, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Status>;

    /**
     * Delete a specific status.
     * @param {string} statusId 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApiInterface
     */
    statusDelete(statusId: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Get a list of all statuses for the authenticated user.
     * @param {number} [page] A page number within the paginated result set.
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {string} [status] Filter by a status value
     * @param {string} [search] Search by keyword against status note or path to green
     * @param {string} [sort] Sort by field (prefix with \&#39;-\&#39; for descending)
     * @param {string} [limit] Sort by field (prefix with \&#39;-\&#39; for descending)
     * @param {string} [goalIds] Filter on goals, using the UUID of the goal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApiInterface
     */
    statusList(page?: number, xUserID?: string, status?: string, search?: string, sort?: string, limit?: string, goalIds?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Status>>;

    /**
     * Partially update a specific status.
     * @param {string} statusId 
     * @param {Status} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApiInterface
     */
    statusPartialUpdate(statusId: string, data: Status, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Status>;

    /**
     * Get details of a specific status.
     * @param {string} statusId 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApiInterface
     */
    statusRead(statusId: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Status>;

    /**
     * Update a specific status.
     * @param {string} statusId 
     * @param {Status} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApiInterface
     */
    statusUpdate(statusId: string, data: Status, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Status>;

}

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI implements StatusApiInterface {
    /**
     * Create a new status for the authenticated user.
     * @param {StatusCreateRequest} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public statusCreate(data: StatusCreateRequest, xUserID?: string, options?: RawAxiosRequestConfig) {
        return StatusApiFp(this.configuration).statusCreate(data, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific status.
     * @param {string} statusId 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public statusDelete(statusId: string, xUserID?: string, options?: RawAxiosRequestConfig) {
        return StatusApiFp(this.configuration).statusDelete(statusId, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all statuses for the authenticated user.
     * @param {number} [page] A page number within the paginated result set.
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {string} [status] Filter by a status value
     * @param {string} [search] Search by keyword against status note or path to green
     * @param {string} [sort] Sort by field (prefix with \&#39;-\&#39; for descending)
     * @param {string} [limit] Sort by field (prefix with \&#39;-\&#39; for descending)
     * @param {string} [goalIds] Filter on goals, using the UUID of the goal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public statusList(page?: number, xUserID?: string, status?: string, search?: string, sort?: string, limit?: string, goalIds?: string, options?: RawAxiosRequestConfig) {
        return StatusApiFp(this.configuration).statusList(page, xUserID, status, search, sort, limit, goalIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Partially update a specific status.
     * @param {string} statusId 
     * @param {Status} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public statusPartialUpdate(statusId: string, data: Status, xUserID?: string, options?: RawAxiosRequestConfig) {
        return StatusApiFp(this.configuration).statusPartialUpdate(statusId, data, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a specific status.
     * @param {string} statusId 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public statusRead(statusId: string, xUserID?: string, options?: RawAxiosRequestConfig) {
        return StatusApiFp(this.configuration).statusRead(statusId, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a specific status.
     * @param {string} statusId 
     * @param {Status} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public statusUpdate(statusId: string, data: Status, xUserID?: string, options?: RawAxiosRequestConfig) {
        return StatusApiFp(this.configuration).statusUpdate(statusId, data, xUserID, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new tag for the authenticated user.
         * @param {Tag} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsCreate: async (data: Tag, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('tagsCreate', 'data', data)
            const localVarPath = `/tags/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific tag.
         * @param {string} tagId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsDelete: async (tagId: string, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('tagsDelete', 'tagId', tagId)
            const localVarPath = `/tags/{tag_id}/`
                .replace(`{${"tag_id"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all tags for the authenticated user.
         * @param {number} [page] A page number within the paginated result set.
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [search] Search tags by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsList: async (page?: number, xUserID?: string, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tags/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Partially update a specific tag.
         * @param {string} tagId 
         * @param {Tag} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsPartialUpdate: async (tagId: string, data: Tag, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('tagsPartialUpdate', 'tagId', tagId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('tagsPartialUpdate', 'data', data)
            const localVarPath = `/tags/{tag_id}/`
                .replace(`{${"tag_id"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a specific tag.
         * @param {string} tagId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsRead: async (tagId: string, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('tagsRead', 'tagId', tagId)
            const localVarPath = `/tags/{tag_id}/`
                .replace(`{${"tag_id"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a specific tag.
         * @param {string} tagId 
         * @param {Tag} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsUpdate: async (tagId: string, data: Tag, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('tagsUpdate', 'tagId', tagId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('tagsUpdate', 'data', data)
            const localVarPath = `/tags/{tag_id}/`
                .replace(`{${"tag_id"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new tag for the authenticated user.
         * @param {Tag} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsCreate(data: Tag, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsCreate(data, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.tagsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specific tag.
         * @param {string} tagId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsDelete(tagId: string, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsDelete(tagId, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.tagsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of all tags for the authenticated user.
         * @param {number} [page] A page number within the paginated result set.
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [search] Search tags by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsList(page?: number, xUserID?: string, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsList(page, xUserID, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.tagsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Partially update a specific tag.
         * @param {string} tagId 
         * @param {Tag} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsPartialUpdate(tagId: string, data: Tag, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsPartialUpdate(tagId, data, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.tagsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get details of a specific tag.
         * @param {string} tagId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsRead(tagId: string, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsRead(tagId, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.tagsRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a specific tag.
         * @param {string} tagId 
         * @param {Tag} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsUpdate(tagId: string, data: Tag, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsUpdate(tagId, data, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.tagsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * Create a new tag for the authenticated user.
         * @param {Tag} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsCreate(data: Tag, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Tag> {
            return localVarFp.tagsCreate(data, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific tag.
         * @param {string} tagId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsDelete(tagId: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tagsDelete(tagId, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all tags for the authenticated user.
         * @param {number} [page] A page number within the paginated result set.
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [search] Search tags by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsList(page?: number, xUserID?: string, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Tag>> {
            return localVarFp.tagsList(page, xUserID, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Partially update a specific tag.
         * @param {string} tagId 
         * @param {Tag} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsPartialUpdate(tagId: string, data: Tag, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Tag> {
            return localVarFp.tagsPartialUpdate(tagId, data, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a specific tag.
         * @param {string} tagId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsRead(tagId: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Tag> {
            return localVarFp.tagsRead(tagId, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a specific tag.
         * @param {string} tagId 
         * @param {Tag} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsUpdate(tagId: string, data: Tag, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Tag> {
            return localVarFp.tagsUpdate(tagId, data, xUserID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - interface
 * @export
 * @interface TagsApi
 */
export interface TagsApiInterface {
    /**
     * Create a new tag for the authenticated user.
     * @param {Tag} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiInterface
     */
    tagsCreate(data: Tag, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Tag>;

    /**
     * Delete a specific tag.
     * @param {string} tagId 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiInterface
     */
    tagsDelete(tagId: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Get a list of all tags for the authenticated user.
     * @param {number} [page] A page number within the paginated result set.
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {string} [search] Search tags by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiInterface
     */
    tagsList(page?: number, xUserID?: string, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Tag>>;

    /**
     * Partially update a specific tag.
     * @param {string} tagId 
     * @param {Tag} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiInterface
     */
    tagsPartialUpdate(tagId: string, data: Tag, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Tag>;

    /**
     * Get details of a specific tag.
     * @param {string} tagId 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiInterface
     */
    tagsRead(tagId: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Tag>;

    /**
     * Update a specific tag.
     * @param {string} tagId 
     * @param {Tag} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiInterface
     */
    tagsUpdate(tagId: string, data: Tag, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Tag>;

}

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI implements TagsApiInterface {
    /**
     * Create a new tag for the authenticated user.
     * @param {Tag} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsCreate(data: Tag, xUserID?: string, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagsCreate(data, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific tag.
     * @param {string} tagId 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsDelete(tagId: string, xUserID?: string, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagsDelete(tagId, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all tags for the authenticated user.
     * @param {number} [page] A page number within the paginated result set.
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {string} [search] Search tags by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsList(page?: number, xUserID?: string, search?: string, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagsList(page, xUserID, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Partially update a specific tag.
     * @param {string} tagId 
     * @param {Tag} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsPartialUpdate(tagId: string, data: Tag, xUserID?: string, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagsPartialUpdate(tagId, data, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a specific tag.
     * @param {string} tagId 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsRead(tagId: string, xUserID?: string, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagsRead(tagId, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a specific tag.
     * @param {string} tagId 
     * @param {Tag} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsUpdate(tagId: string, data: Tag, xUserID?: string, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagsUpdate(tagId, data, xUserID, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new user for the authenticated user\'s organization.
         * @param {User} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreate: async (data: User, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersCreate', 'data', data)
            const localVarPath = `/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersDelete', 'id', id)
            const localVarPath = `/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve one or more users
         * @param {number} [page] A page number within the paginated result set.
         * @param {string} [search] Search term for filtering users by email, last name, or first name
         * @param {string} [domain] Search term for filtering users by the domain of the organzation
         * @param {number} [limit] Maximum number of results to return
         * @param {string} [sort] Field to sort the results by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersList: async (page?: number, search?: string, domain?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (domain !== undefined) {
                localVarQueryParameter['domain'] = domain;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {User} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPartialUpdate: async (id: string, data: User, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersPartialUpdate', 'data', data)
            const localVarPath = `/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve list of users matching none or all of search parameters.
         * @param {string} [search] Search term for filtering users by email, last name, or first name
         * @param {string} [sort] Field to sort the results by
         * @param {number} [limit] Maximum number of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPickerList: async (search?: string, sort?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/picker/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all PRDs for the authenticated user\'s organization.
         * @param {string} id 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRead: async (id: string, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersRead', 'id', id)
            const localVarPath = `/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a specific user\'s details
         * @param {string} id UUID of the user to update
         * @param {User} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdate: async (id: string, data: User, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersUpdate', 'data', data)
            const localVarPath = `/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new user for the authenticated user\'s organization.
         * @param {User} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersCreate(data: User, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersCreate(data, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve one or more users
         * @param {number} [page] A page number within the paginated result set.
         * @param {string} [search] Search term for filtering users by email, last name, or first name
         * @param {string} [domain] Search term for filtering users by the domain of the organzation
         * @param {number} [limit] Maximum number of results to return
         * @param {string} [sort] Field to sort the results by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersList(page?: number, search?: string, domain?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersList(page, search, domain, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {User} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPartialUpdate(id: string, data: User, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPartialUpdate(id, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve list of users matching none or all of search parameters.
         * @param {string} [search] Search term for filtering users by email, last name, or first name
         * @param {string} [sort] Field to sort the results by
         * @param {number} [limit] Maximum number of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPickerList(search?: string, sort?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPickerList(search, sort, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersPickerList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of all PRDs for the authenticated user\'s organization.
         * @param {string} id 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersRead(id: string, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersRead(id, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a specific user\'s details
         * @param {string} id UUID of the user to update
         * @param {User} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUpdate(id: string, data: User, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUpdate(id, data, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Create a new user for the authenticated user\'s organization.
         * @param {User} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreate(data: User, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersCreate(data, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve one or more users
         * @param {number} [page] A page number within the paginated result set.
         * @param {string} [search] Search term for filtering users by email, last name, or first name
         * @param {string} [domain] Search term for filtering users by the domain of the organzation
         * @param {number} [limit] Maximum number of results to return
         * @param {string} [sort] Field to sort the results by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersList(page?: number, search?: string, domain?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.usersList(page, search, domain, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {User} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPartialUpdate(id: string, data: User, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve list of users matching none or all of search parameters.
         * @param {string} [search] Search term for filtering users by email, last name, or first name
         * @param {string} [sort] Field to sort the results by
         * @param {number} [limit] Maximum number of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPickerList(search?: string, sort?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.usersPickerList(search, sort, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all PRDs for the authenticated user\'s organization.
         * @param {string} id 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRead(id: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.usersRead(id, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a specific user\'s details
         * @param {string} id UUID of the user to update
         * @param {User} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdate(id: string, data: User, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersUpdate(id, data, xUserID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - interface
 * @export
 * @interface UsersApi
 */
export interface UsersApiInterface {
    /**
     * Create a new user for the authenticated user\'s organization.
     * @param {User} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersCreate(data: User, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<User>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieve one or more users
     * @param {number} [page] A page number within the paginated result set.
     * @param {string} [search] Search term for filtering users by email, last name, or first name
     * @param {string} [domain] Search term for filtering users by the domain of the organzation
     * @param {number} [limit] Maximum number of results to return
     * @param {string} [sort] Field to sort the results by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersList(page?: number, search?: string, domain?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<User>>;

    /**
     * 
     * @param {string} id 
     * @param {User} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersPartialUpdate(id: string, data: User, options?: RawAxiosRequestConfig): AxiosPromise<User>;

    /**
     * Retrieve list of users matching none or all of search parameters.
     * @param {string} [search] Search term for filtering users by email, last name, or first name
     * @param {string} [sort] Field to sort the results by
     * @param {number} [limit] Maximum number of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersPickerList(search?: string, sort?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<User>>;

    /**
     * Get a list of all PRDs for the authenticated user\'s organization.
     * @param {string} id 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersRead(id: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<User>>;

    /**
     * Update a specific user\'s details
     * @param {string} id UUID of the user to update
     * @param {User} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersUpdate(id: string, data: User, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<User>;

}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI implements UsersApiInterface {
    /**
     * Create a new user for the authenticated user\'s organization.
     * @param {User} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersCreate(data: User, xUserID?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersCreate(data, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersDelete(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve one or more users
     * @param {number} [page] A page number within the paginated result set.
     * @param {string} [search] Search term for filtering users by email, last name, or first name
     * @param {string} [domain] Search term for filtering users by the domain of the organzation
     * @param {number} [limit] Maximum number of results to return
     * @param {string} [sort] Field to sort the results by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersList(page?: number, search?: string, domain?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersList(page, search, domain, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {User} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPartialUpdate(id: string, data: User, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve list of users matching none or all of search parameters.
     * @param {string} [search] Search term for filtering users by email, last name, or first name
     * @param {string} [sort] Field to sort the results by
     * @param {number} [limit] Maximum number of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPickerList(search?: string, sort?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersPickerList(search, sort, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all PRDs for the authenticated user\'s organization.
     * @param {string} id 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersRead(id: string, xUserID?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersRead(id, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a specific user\'s details
     * @param {string} id UUID of the user to update
     * @param {User} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUpdate(id: string, data: User, xUserID?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUpdate(id, data, xUserID, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserstoriesApi - axios parameter creator
 * @export
 */
export const UserstoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new user story.
         * @param {UserstoriesCreateRequest} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userstoriesCreate: async (data: UserstoriesCreateRequest, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('userstoriesCreate', 'data', data)
            const localVarPath = `/userstories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific user story.
         * @param {string} userstoryId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userstoriesDelete: async (userstoryId: string, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userstoryId' is not null or undefined
            assertParamExists('userstoriesDelete', 'userstoryId', userstoryId)
            const localVarPath = `/userstories/{userstory_id}/`
                .replace(`{${"userstory_id"}}`, encodeURIComponent(String(userstoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List or Search for User Stories
         * @param {string} [search] Search term for as_a, i_want_to, so_that, or freetext_override fields
         * @param {string} [status] Filter by status
         * @param {number} [prd] Filter by PRD ID
         * @param {string} [sort] Sort field (prefix with \&#39;-\&#39; for descending order)
         * @param {number} [limit] Limit the number of results
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [format] Response format (json or excel, default is json)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userstoriesList: async (search?: string, status?: string, prd?: number, sort?: string, limit?: number, xUserID?: string, format?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/userstories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (prd !== undefined) {
                localVarQueryParameter['prd'] = prd;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Partially update a specific user story.
         * @param {string} userstoryId 
         * @param {UserStory} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userstoriesPartialUpdate: async (userstoryId: string, data: UserStory, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userstoryId' is not null or undefined
            assertParamExists('userstoriesPartialUpdate', 'userstoryId', userstoryId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('userstoriesPartialUpdate', 'data', data)
            const localVarPath = `/userstories/{userstory_id}/`
                .replace(`{${"userstory_id"}}`, encodeURIComponent(String(userstoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a specific user story.
         * @param {string} userstoryId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userstoriesRead: async (userstoryId: string, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userstoryId' is not null or undefined
            assertParamExists('userstoriesRead', 'userstoryId', userstoryId)
            const localVarPath = `/userstories/{userstory_id}/`
                .replace(`{${"userstory_id"}}`, encodeURIComponent(String(userstoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a specific user story.
         * @param {string} userstoryId 
         * @param {UserStory} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userstoriesUpdate: async (userstoryId: string, data: UserStory, xUserID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userstoryId' is not null or undefined
            assertParamExists('userstoriesUpdate', 'userstoryId', userstoryId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('userstoriesUpdate', 'data', data)
            const localVarPath = `/userstories/{userstory_id}/`
                .replace(`{${"userstory_id"}}`, encodeURIComponent(String(userstoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserIdAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-ID", configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xUserID != null) {
                localVarHeaderParameter['X-User-ID'] = String(xUserID);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserstoriesApi - functional programming interface
 * @export
 */
export const UserstoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserstoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new user story.
         * @param {UserstoriesCreateRequest} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userstoriesCreate(data: UserstoriesCreateRequest, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserStory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userstoriesCreate(data, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserstoriesApi.userstoriesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specific user story.
         * @param {string} userstoryId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userstoriesDelete(userstoryId: string, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userstoriesDelete(userstoryId, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserstoriesApi.userstoriesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List or Search for User Stories
         * @param {string} [search] Search term for as_a, i_want_to, so_that, or freetext_override fields
         * @param {string} [status] Filter by status
         * @param {number} [prd] Filter by PRD ID
         * @param {string} [sort] Sort field (prefix with \&#39;-\&#39; for descending order)
         * @param {number} [limit] Limit the number of results
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [format] Response format (json or excel, default is json)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userstoriesList(search?: string, status?: string, prd?: number, sort?: string, limit?: number, xUserID?: string, format?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserStory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userstoriesList(search, status, prd, sort, limit, xUserID, format, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserstoriesApi.userstoriesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Partially update a specific user story.
         * @param {string} userstoryId 
         * @param {UserStory} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userstoriesPartialUpdate(userstoryId: string, data: UserStory, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserStory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userstoriesPartialUpdate(userstoryId, data, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserstoriesApi.userstoriesPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get details of a specific user story.
         * @param {string} userstoryId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userstoriesRead(userstoryId: string, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserStory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userstoriesRead(userstoryId, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserstoriesApi.userstoriesRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a specific user story.
         * @param {string} userstoryId 
         * @param {UserStory} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userstoriesUpdate(userstoryId: string, data: UserStory, xUserID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserStory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userstoriesUpdate(userstoryId, data, xUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserstoriesApi.userstoriesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserstoriesApi - factory interface
 * @export
 */
export const UserstoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserstoriesApiFp(configuration)
    return {
        /**
         * Create a new user story.
         * @param {UserstoriesCreateRequest} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userstoriesCreate(data: UserstoriesCreateRequest, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserStory> {
            return localVarFp.userstoriesCreate(data, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific user story.
         * @param {string} userstoryId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userstoriesDelete(userstoryId: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.userstoriesDelete(userstoryId, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * List or Search for User Stories
         * @param {string} [search] Search term for as_a, i_want_to, so_that, or freetext_override fields
         * @param {string} [status] Filter by status
         * @param {number} [prd] Filter by PRD ID
         * @param {string} [sort] Sort field (prefix with \&#39;-\&#39; for descending order)
         * @param {number} [limit] Limit the number of results
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {string} [format] Response format (json or excel, default is json)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userstoriesList(search?: string, status?: string, prd?: number, sort?: string, limit?: number, xUserID?: string, format?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserStory>> {
            return localVarFp.userstoriesList(search, status, prd, sort, limit, xUserID, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Partially update a specific user story.
         * @param {string} userstoryId 
         * @param {UserStory} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userstoriesPartialUpdate(userstoryId: string, data: UserStory, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserStory> {
            return localVarFp.userstoriesPartialUpdate(userstoryId, data, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a specific user story.
         * @param {string} userstoryId 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userstoriesRead(userstoryId: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserStory> {
            return localVarFp.userstoriesRead(userstoryId, xUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a specific user story.
         * @param {string} userstoryId 
         * @param {UserStory} data 
         * @param {string} [xUserID] User ID (required when using API key)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userstoriesUpdate(userstoryId: string, data: UserStory, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserStory> {
            return localVarFp.userstoriesUpdate(userstoryId, data, xUserID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserstoriesApi - interface
 * @export
 * @interface UserstoriesApi
 */
export interface UserstoriesApiInterface {
    /**
     * Create a new user story.
     * @param {UserstoriesCreateRequest} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserstoriesApiInterface
     */
    userstoriesCreate(data: UserstoriesCreateRequest, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserStory>;

    /**
     * Delete a specific user story.
     * @param {string} userstoryId 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserstoriesApiInterface
     */
    userstoriesDelete(userstoryId: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * List or Search for User Stories
     * @param {string} [search] Search term for as_a, i_want_to, so_that, or freetext_override fields
     * @param {string} [status] Filter by status
     * @param {number} [prd] Filter by PRD ID
     * @param {string} [sort] Sort field (prefix with \&#39;-\&#39; for descending order)
     * @param {number} [limit] Limit the number of results
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {string} [format] Response format (json or excel, default is json)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserstoriesApiInterface
     */
    userstoriesList(search?: string, status?: string, prd?: number, sort?: string, limit?: number, xUserID?: string, format?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserStory>>;

    /**
     * Partially update a specific user story.
     * @param {string} userstoryId 
     * @param {UserStory} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserstoriesApiInterface
     */
    userstoriesPartialUpdate(userstoryId: string, data: UserStory, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserStory>;

    /**
     * Get details of a specific user story.
     * @param {string} userstoryId 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserstoriesApiInterface
     */
    userstoriesRead(userstoryId: string, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserStory>;

    /**
     * Update a specific user story.
     * @param {string} userstoryId 
     * @param {UserStory} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserstoriesApiInterface
     */
    userstoriesUpdate(userstoryId: string, data: UserStory, xUserID?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserStory>;

}

/**
 * UserstoriesApi - object-oriented interface
 * @export
 * @class UserstoriesApi
 * @extends {BaseAPI}
 */
export class UserstoriesApi extends BaseAPI implements UserstoriesApiInterface {
    /**
     * Create a new user story.
     * @param {UserstoriesCreateRequest} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserstoriesApi
     */
    public userstoriesCreate(data: UserstoriesCreateRequest, xUserID?: string, options?: RawAxiosRequestConfig) {
        return UserstoriesApiFp(this.configuration).userstoriesCreate(data, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific user story.
     * @param {string} userstoryId 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserstoriesApi
     */
    public userstoriesDelete(userstoryId: string, xUserID?: string, options?: RawAxiosRequestConfig) {
        return UserstoriesApiFp(this.configuration).userstoriesDelete(userstoryId, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List or Search for User Stories
     * @param {string} [search] Search term for as_a, i_want_to, so_that, or freetext_override fields
     * @param {string} [status] Filter by status
     * @param {number} [prd] Filter by PRD ID
     * @param {string} [sort] Sort field (prefix with \&#39;-\&#39; for descending order)
     * @param {number} [limit] Limit the number of results
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {string} [format] Response format (json or excel, default is json)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserstoriesApi
     */
    public userstoriesList(search?: string, status?: string, prd?: number, sort?: string, limit?: number, xUserID?: string, format?: string, options?: RawAxiosRequestConfig) {
        return UserstoriesApiFp(this.configuration).userstoriesList(search, status, prd, sort, limit, xUserID, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Partially update a specific user story.
     * @param {string} userstoryId 
     * @param {UserStory} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserstoriesApi
     */
    public userstoriesPartialUpdate(userstoryId: string, data: UserStory, xUserID?: string, options?: RawAxiosRequestConfig) {
        return UserstoriesApiFp(this.configuration).userstoriesPartialUpdate(userstoryId, data, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a specific user story.
     * @param {string} userstoryId 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserstoriesApi
     */
    public userstoriesRead(userstoryId: string, xUserID?: string, options?: RawAxiosRequestConfig) {
        return UserstoriesApiFp(this.configuration).userstoriesRead(userstoryId, xUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a specific user story.
     * @param {string} userstoryId 
     * @param {UserStory} data 
     * @param {string} [xUserID] User ID (required when using API key)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserstoriesApi
     */
    public userstoriesUpdate(userstoryId: string, data: UserStory, xUserID?: string, options?: RawAxiosRequestConfig) {
        return UserstoriesApiFp(this.configuration).userstoriesUpdate(userstoryId, data, xUserID, options).then((request) => request(this.axios, this.basePath));
    }
}



